// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: config.proto
// Protobuf C++ Version: 6.30.1

#ifndef config_2eproto_2epb_2eh
#define config_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6030001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_config_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_config_2eproto {
  static const ::uint32_t offsets[];
};
namespace webrtc {
namespace audio_network_adaptor {
namespace config {
class BitrateController;
struct BitrateControllerDefaultTypeInternal;
extern BitrateControllerDefaultTypeInternal _BitrateController_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<54> BitrateController_class_data_;
class ChannelController;
struct ChannelControllerDefaultTypeInternal;
extern ChannelControllerDefaultTypeInternal _ChannelController_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<54> ChannelController_class_data_;
class Controller;
struct ControllerDefaultTypeInternal;
extern ControllerDefaultTypeInternal _Controller_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<47> Controller_class_data_;
class ControllerManager;
struct ControllerManagerDefaultTypeInternal;
extern ControllerManagerDefaultTypeInternal _ControllerManager_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<54> ControllerManager_class_data_;
class Controller_ScoringPoint;
struct Controller_ScoringPointDefaultTypeInternal;
extern Controller_ScoringPointDefaultTypeInternal _Controller_ScoringPoint_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<60> Controller_ScoringPoint_class_data_;
class DtxController;
struct DtxControllerDefaultTypeInternal;
extern DtxControllerDefaultTypeInternal _DtxController_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<50> DtxController_class_data_;
class FecController;
struct FecControllerDefaultTypeInternal;
extern FecControllerDefaultTypeInternal _FecController_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<50> FecController_class_data_;
class FecControllerRplrBased;
struct FecControllerRplrBasedDefaultTypeInternal;
extern FecControllerRplrBasedDefaultTypeInternal _FecControllerRplrBased_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<59> FecControllerRplrBased_class_data_;
class FecControllerRplrBased_Threshold;
struct FecControllerRplrBased_ThresholdDefaultTypeInternal;
extern FecControllerRplrBased_ThresholdDefaultTypeInternal _FecControllerRplrBased_Threshold_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<69> FecControllerRplrBased_Threshold_class_data_;
class FecController_Threshold;
struct FecController_ThresholdDefaultTypeInternal;
extern FecController_ThresholdDefaultTypeInternal _FecController_Threshold_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<60> FecController_Threshold_class_data_;
class FrameLengthController;
struct FrameLengthControllerDefaultTypeInternal;
extern FrameLengthControllerDefaultTypeInternal _FrameLengthController_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<58> FrameLengthController_class_data_;
class FrameLengthControllerV2;
struct FrameLengthControllerV2DefaultTypeInternal;
extern FrameLengthControllerV2DefaultTypeInternal _FrameLengthControllerV2_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<60> FrameLengthControllerV2_class_data_;
}  // namespace config
}  // namespace audio_network_adaptor
}  // namespace webrtc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace webrtc {
namespace audio_network_adaptor {
namespace config {

// ===================================================================


// -------------------------------------------------------------------

class FrameLengthControllerV2 final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FrameLengthControllerV2) */ {
 public:
  inline FrameLengthControllerV2() : FrameLengthControllerV2(nullptr) {}
  ~FrameLengthControllerV2() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FrameLengthControllerV2* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FrameLengthControllerV2));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FrameLengthControllerV2(::google::protobuf::internal::ConstantInitialized);

  inline FrameLengthControllerV2(const FrameLengthControllerV2& from) : FrameLengthControllerV2(nullptr, from) {}
  inline FrameLengthControllerV2(FrameLengthControllerV2&& from) noexcept
      : FrameLengthControllerV2(nullptr, std::move(from)) {}
  inline FrameLengthControllerV2& operator=(const FrameLengthControllerV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameLengthControllerV2& operator=(FrameLengthControllerV2&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FrameLengthControllerV2& default_instance() {
    return *reinterpret_cast<const FrameLengthControllerV2*>(
        &_FrameLengthControllerV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(FrameLengthControllerV2& a, FrameLengthControllerV2& b) { a.Swap(&b); }
  inline void Swap(FrameLengthControllerV2* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameLengthControllerV2* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameLengthControllerV2* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<FrameLengthControllerV2>(arena);
  }
  void CopyFrom(const FrameLengthControllerV2& from);
  void MergeFrom(const FrameLengthControllerV2& from) { FrameLengthControllerV2::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FrameLengthControllerV2* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.FrameLengthControllerV2"; }

 protected:
  explicit FrameLengthControllerV2(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FrameLengthControllerV2(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FrameLengthControllerV2& from);
  FrameLengthControllerV2(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FrameLengthControllerV2&& from) noexcept
      : FrameLengthControllerV2(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMinPayloadBitrateBpsFieldNumber = 1,
    kUseSlowAdaptationFieldNumber = 2,
  };
  // optional int32 min_payload_bitrate_bps = 1;
  bool has_min_payload_bitrate_bps() const;
  void clear_min_payload_bitrate_bps() ;
  ::int32_t min_payload_bitrate_bps() const;
  void set_min_payload_bitrate_bps(::int32_t value);

  private:
  ::int32_t _internal_min_payload_bitrate_bps() const;
  void _internal_set_min_payload_bitrate_bps(::int32_t value);

  public:
  // optional bool use_slow_adaptation = 2;
  bool has_use_slow_adaptation() const;
  void clear_use_slow_adaptation() ;
  bool use_slow_adaptation() const;
  void set_use_slow_adaptation(bool value);

  private:
  bool _internal_use_slow_adaptation() const;
  void _internal_set_use_slow_adaptation(bool value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FrameLengthControllerV2)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FrameLengthControllerV2& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t min_payload_bitrate_bps_;
    bool use_slow_adaptation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<60> FrameLengthControllerV2_class_data_;
// -------------------------------------------------------------------

class FrameLengthController final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FrameLengthController) */ {
 public:
  inline FrameLengthController() : FrameLengthController(nullptr) {}
  ~FrameLengthController() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FrameLengthController* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FrameLengthController));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FrameLengthController(::google::protobuf::internal::ConstantInitialized);

  inline FrameLengthController(const FrameLengthController& from) : FrameLengthController(nullptr, from) {}
  inline FrameLengthController(FrameLengthController&& from) noexcept
      : FrameLengthController(nullptr, std::move(from)) {}
  inline FrameLengthController& operator=(const FrameLengthController& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameLengthController& operator=(FrameLengthController&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FrameLengthController& default_instance() {
    return *reinterpret_cast<const FrameLengthController*>(
        &_FrameLengthController_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(FrameLengthController& a, FrameLengthController& b) { a.Swap(&b); }
  inline void Swap(FrameLengthController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameLengthController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameLengthController* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<FrameLengthController>(arena);
  }
  void CopyFrom(const FrameLengthController& from);
  void MergeFrom(const FrameLengthController& from) { FrameLengthController::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FrameLengthController* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.FrameLengthController"; }

 protected:
  explicit FrameLengthController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FrameLengthController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FrameLengthController& from);
  FrameLengthController(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FrameLengthController&& from) noexcept
      : FrameLengthController(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFlIncreasingPacketLossFractionFieldNumber = 1,
    kFlDecreasingPacketLossFractionFieldNumber = 2,
    kFl20MsTo60MsBandwidthBpsFieldNumber = 3,
    kFl60MsTo20MsBandwidthBpsFieldNumber = 4,
    kFl60MsTo120MsBandwidthBpsFieldNumber = 5,
    kFl120MsTo60MsBandwidthBpsFieldNumber = 6,
    kFlIncreaseOverheadOffsetFieldNumber = 7,
    kFlDecreaseOverheadOffsetFieldNumber = 8,
    kFl20MsTo40MsBandwidthBpsFieldNumber = 9,
    kFl40MsTo20MsBandwidthBpsFieldNumber = 10,
    kFl40MsTo60MsBandwidthBpsFieldNumber = 11,
    kFl60MsTo40MsBandwidthBpsFieldNumber = 12,
  };
  // optional float fl_increasing_packet_loss_fraction = 1;
  bool has_fl_increasing_packet_loss_fraction() const;
  void clear_fl_increasing_packet_loss_fraction() ;
  float fl_increasing_packet_loss_fraction() const;
  void set_fl_increasing_packet_loss_fraction(float value);

  private:
  float _internal_fl_increasing_packet_loss_fraction() const;
  void _internal_set_fl_increasing_packet_loss_fraction(float value);

  public:
  // optional float fl_decreasing_packet_loss_fraction = 2;
  bool has_fl_decreasing_packet_loss_fraction() const;
  void clear_fl_decreasing_packet_loss_fraction() ;
  float fl_decreasing_packet_loss_fraction() const;
  void set_fl_decreasing_packet_loss_fraction(float value);

  private:
  float _internal_fl_decreasing_packet_loss_fraction() const;
  void _internal_set_fl_decreasing_packet_loss_fraction(float value);

  public:
  // optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
  bool has_fl_20ms_to_60ms_bandwidth_bps() const;
  void clear_fl_20ms_to_60ms_bandwidth_bps() ;
  ::int32_t fl_20ms_to_60ms_bandwidth_bps() const;
  void set_fl_20ms_to_60ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_20ms_to_60ms_bandwidth_bps() const;
  void _internal_set_fl_20ms_to_60ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
  bool has_fl_60ms_to_20ms_bandwidth_bps() const;
  void clear_fl_60ms_to_20ms_bandwidth_bps() ;
  ::int32_t fl_60ms_to_20ms_bandwidth_bps() const;
  void set_fl_60ms_to_20ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_60ms_to_20ms_bandwidth_bps() const;
  void _internal_set_fl_60ms_to_20ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_60ms_to_120ms_bandwidth_bps = 5;
  bool has_fl_60ms_to_120ms_bandwidth_bps() const;
  void clear_fl_60ms_to_120ms_bandwidth_bps() ;
  ::int32_t fl_60ms_to_120ms_bandwidth_bps() const;
  void set_fl_60ms_to_120ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_60ms_to_120ms_bandwidth_bps() const;
  void _internal_set_fl_60ms_to_120ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_120ms_to_60ms_bandwidth_bps = 6;
  bool has_fl_120ms_to_60ms_bandwidth_bps() const;
  void clear_fl_120ms_to_60ms_bandwidth_bps() ;
  ::int32_t fl_120ms_to_60ms_bandwidth_bps() const;
  void set_fl_120ms_to_60ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_120ms_to_60ms_bandwidth_bps() const;
  void _internal_set_fl_120ms_to_60ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_increase_overhead_offset = 7;
  bool has_fl_increase_overhead_offset() const;
  void clear_fl_increase_overhead_offset() ;
  ::int32_t fl_increase_overhead_offset() const;
  void set_fl_increase_overhead_offset(::int32_t value);

  private:
  ::int32_t _internal_fl_increase_overhead_offset() const;
  void _internal_set_fl_increase_overhead_offset(::int32_t value);

  public:
  // optional int32 fl_decrease_overhead_offset = 8;
  bool has_fl_decrease_overhead_offset() const;
  void clear_fl_decrease_overhead_offset() ;
  ::int32_t fl_decrease_overhead_offset() const;
  void set_fl_decrease_overhead_offset(::int32_t value);

  private:
  ::int32_t _internal_fl_decrease_overhead_offset() const;
  void _internal_set_fl_decrease_overhead_offset(::int32_t value);

  public:
  // optional int32 fl_20ms_to_40ms_bandwidth_bps = 9;
  bool has_fl_20ms_to_40ms_bandwidth_bps() const;
  void clear_fl_20ms_to_40ms_bandwidth_bps() ;
  ::int32_t fl_20ms_to_40ms_bandwidth_bps() const;
  void set_fl_20ms_to_40ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_20ms_to_40ms_bandwidth_bps() const;
  void _internal_set_fl_20ms_to_40ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_40ms_to_20ms_bandwidth_bps = 10;
  bool has_fl_40ms_to_20ms_bandwidth_bps() const;
  void clear_fl_40ms_to_20ms_bandwidth_bps() ;
  ::int32_t fl_40ms_to_20ms_bandwidth_bps() const;
  void set_fl_40ms_to_20ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_40ms_to_20ms_bandwidth_bps() const;
  void _internal_set_fl_40ms_to_20ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_40ms_to_60ms_bandwidth_bps = 11;
  bool has_fl_40ms_to_60ms_bandwidth_bps() const;
  void clear_fl_40ms_to_60ms_bandwidth_bps() ;
  ::int32_t fl_40ms_to_60ms_bandwidth_bps() const;
  void set_fl_40ms_to_60ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_40ms_to_60ms_bandwidth_bps() const;
  void _internal_set_fl_40ms_to_60ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_60ms_to_40ms_bandwidth_bps = 12;
  bool has_fl_60ms_to_40ms_bandwidth_bps() const;
  void clear_fl_60ms_to_40ms_bandwidth_bps() ;
  ::int32_t fl_60ms_to_40ms_bandwidth_bps() const;
  void set_fl_60ms_to_40ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_60ms_to_40ms_bandwidth_bps() const;
  void _internal_set_fl_60ms_to_40ms_bandwidth_bps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FrameLengthController)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FrameLengthController& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float fl_increasing_packet_loss_fraction_;
    float fl_decreasing_packet_loss_fraction_;
    ::int32_t fl_20ms_to_60ms_bandwidth_bps_;
    ::int32_t fl_60ms_to_20ms_bandwidth_bps_;
    ::int32_t fl_60ms_to_120ms_bandwidth_bps_;
    ::int32_t fl_120ms_to_60ms_bandwidth_bps_;
    ::int32_t fl_increase_overhead_offset_;
    ::int32_t fl_decrease_overhead_offset_;
    ::int32_t fl_20ms_to_40ms_bandwidth_bps_;
    ::int32_t fl_40ms_to_20ms_bandwidth_bps_;
    ::int32_t fl_40ms_to_60ms_bandwidth_bps_;
    ::int32_t fl_60ms_to_40ms_bandwidth_bps_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<58> FrameLengthController_class_data_;
// -------------------------------------------------------------------

class FecControllerRplrBased_Threshold final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold) */ {
 public:
  inline FecControllerRplrBased_Threshold() : FecControllerRplrBased_Threshold(nullptr) {}
  ~FecControllerRplrBased_Threshold() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FecControllerRplrBased_Threshold* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FecControllerRplrBased_Threshold));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FecControllerRplrBased_Threshold(::google::protobuf::internal::ConstantInitialized);

  inline FecControllerRplrBased_Threshold(const FecControllerRplrBased_Threshold& from) : FecControllerRplrBased_Threshold(nullptr, from) {}
  inline FecControllerRplrBased_Threshold(FecControllerRplrBased_Threshold&& from) noexcept
      : FecControllerRplrBased_Threshold(nullptr, std::move(from)) {}
  inline FecControllerRplrBased_Threshold& operator=(const FecControllerRplrBased_Threshold& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecControllerRplrBased_Threshold& operator=(FecControllerRplrBased_Threshold&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FecControllerRplrBased_Threshold& default_instance() {
    return *reinterpret_cast<const FecControllerRplrBased_Threshold*>(
        &_FecControllerRplrBased_Threshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(FecControllerRplrBased_Threshold& a, FecControllerRplrBased_Threshold& b) { a.Swap(&b); }
  inline void Swap(FecControllerRplrBased_Threshold* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FecControllerRplrBased_Threshold* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FecControllerRplrBased_Threshold* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<FecControllerRplrBased_Threshold>(arena);
  }
  void CopyFrom(const FecControllerRplrBased_Threshold& from);
  void MergeFrom(const FecControllerRplrBased_Threshold& from) { FecControllerRplrBased_Threshold::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FecControllerRplrBased_Threshold* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold"; }

 protected:
  explicit FecControllerRplrBased_Threshold(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FecControllerRplrBased_Threshold(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FecControllerRplrBased_Threshold& from);
  FecControllerRplrBased_Threshold(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FecControllerRplrBased_Threshold&& from) noexcept
      : FecControllerRplrBased_Threshold(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLowBandwidthBpsFieldNumber = 1,
    kLowBandwidthRecoverablePacketLossFieldNumber = 2,
    kHighBandwidthBpsFieldNumber = 3,
    kHighBandwidthRecoverablePacketLossFieldNumber = 4,
  };
  // optional int32 low_bandwidth_bps = 1;
  bool has_low_bandwidth_bps() const;
  void clear_low_bandwidth_bps() ;
  ::int32_t low_bandwidth_bps() const;
  void set_low_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_low_bandwidth_bps() const;
  void _internal_set_low_bandwidth_bps(::int32_t value);

  public:
  // optional float low_bandwidth_recoverable_packet_loss = 2;
  bool has_low_bandwidth_recoverable_packet_loss() const;
  void clear_low_bandwidth_recoverable_packet_loss() ;
  float low_bandwidth_recoverable_packet_loss() const;
  void set_low_bandwidth_recoverable_packet_loss(float value);

  private:
  float _internal_low_bandwidth_recoverable_packet_loss() const;
  void _internal_set_low_bandwidth_recoverable_packet_loss(float value);

  public:
  // optional int32 high_bandwidth_bps = 3;
  bool has_high_bandwidth_bps() const;
  void clear_high_bandwidth_bps() ;
  ::int32_t high_bandwidth_bps() const;
  void set_high_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_high_bandwidth_bps() const;
  void _internal_set_high_bandwidth_bps(::int32_t value);

  public:
  // optional float high_bandwidth_recoverable_packet_loss = 4;
  bool has_high_bandwidth_recoverable_packet_loss() const;
  void clear_high_bandwidth_recoverable_packet_loss() ;
  float high_bandwidth_recoverable_packet_loss() const;
  void set_high_bandwidth_recoverable_packet_loss(float value);

  private:
  float _internal_high_bandwidth_recoverable_packet_loss() const;
  void _internal_set_high_bandwidth_recoverable_packet_loss(float value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FecControllerRplrBased_Threshold& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t low_bandwidth_bps_;
    float low_bandwidth_recoverable_packet_loss_;
    ::int32_t high_bandwidth_bps_;
    float high_bandwidth_recoverable_packet_loss_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<69> FecControllerRplrBased_Threshold_class_data_;
// -------------------------------------------------------------------

class FecController_Threshold final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecController.Threshold) */ {
 public:
  inline FecController_Threshold() : FecController_Threshold(nullptr) {}
  ~FecController_Threshold() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FecController_Threshold* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FecController_Threshold));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FecController_Threshold(::google::protobuf::internal::ConstantInitialized);

  inline FecController_Threshold(const FecController_Threshold& from) : FecController_Threshold(nullptr, from) {}
  inline FecController_Threshold(FecController_Threshold&& from) noexcept
      : FecController_Threshold(nullptr, std::move(from)) {}
  inline FecController_Threshold& operator=(const FecController_Threshold& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecController_Threshold& operator=(FecController_Threshold&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FecController_Threshold& default_instance() {
    return *reinterpret_cast<const FecController_Threshold*>(
        &_FecController_Threshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(FecController_Threshold& a, FecController_Threshold& b) { a.Swap(&b); }
  inline void Swap(FecController_Threshold* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FecController_Threshold* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FecController_Threshold* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<FecController_Threshold>(arena);
  }
  void CopyFrom(const FecController_Threshold& from);
  void MergeFrom(const FecController_Threshold& from) { FecController_Threshold::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FecController_Threshold* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.FecController.Threshold"; }

 protected:
  explicit FecController_Threshold(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FecController_Threshold(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FecController_Threshold& from);
  FecController_Threshold(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FecController_Threshold&& from) noexcept
      : FecController_Threshold(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLowBandwidthBpsFieldNumber = 1,
    kLowBandwidthPacketLossFieldNumber = 2,
    kHighBandwidthBpsFieldNumber = 3,
    kHighBandwidthPacketLossFieldNumber = 4,
  };
  // optional int32 low_bandwidth_bps = 1;
  bool has_low_bandwidth_bps() const;
  void clear_low_bandwidth_bps() ;
  ::int32_t low_bandwidth_bps() const;
  void set_low_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_low_bandwidth_bps() const;
  void _internal_set_low_bandwidth_bps(::int32_t value);

  public:
  // optional float low_bandwidth_packet_loss = 2;
  bool has_low_bandwidth_packet_loss() const;
  void clear_low_bandwidth_packet_loss() ;
  float low_bandwidth_packet_loss() const;
  void set_low_bandwidth_packet_loss(float value);

  private:
  float _internal_low_bandwidth_packet_loss() const;
  void _internal_set_low_bandwidth_packet_loss(float value);

  public:
  // optional int32 high_bandwidth_bps = 3;
  bool has_high_bandwidth_bps() const;
  void clear_high_bandwidth_bps() ;
  ::int32_t high_bandwidth_bps() const;
  void set_high_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_high_bandwidth_bps() const;
  void _internal_set_high_bandwidth_bps(::int32_t value);

  public:
  // optional float high_bandwidth_packet_loss = 4;
  bool has_high_bandwidth_packet_loss() const;
  void clear_high_bandwidth_packet_loss() ;
  float high_bandwidth_packet_loss() const;
  void set_high_bandwidth_packet_loss(float value);

  private:
  float _internal_high_bandwidth_packet_loss() const;
  void _internal_set_high_bandwidth_packet_loss(float value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecController.Threshold)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FecController_Threshold& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t low_bandwidth_bps_;
    float low_bandwidth_packet_loss_;
    ::int32_t high_bandwidth_bps_;
    float high_bandwidth_packet_loss_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<60> FecController_Threshold_class_data_;
// -------------------------------------------------------------------

class DtxController final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.DtxController) */ {
 public:
  inline DtxController() : DtxController(nullptr) {}
  ~DtxController() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DtxController* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DtxController));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DtxController(::google::protobuf::internal::ConstantInitialized);

  inline DtxController(const DtxController& from) : DtxController(nullptr, from) {}
  inline DtxController(DtxController&& from) noexcept
      : DtxController(nullptr, std::move(from)) {}
  inline DtxController& operator=(const DtxController& from) {
    CopyFrom(from);
    return *this;
  }
  inline DtxController& operator=(DtxController&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DtxController& default_instance() {
    return *reinterpret_cast<const DtxController*>(
        &_DtxController_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DtxController& a, DtxController& b) { a.Swap(&b); }
  inline void Swap(DtxController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DtxController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DtxController* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<DtxController>(arena);
  }
  void CopyFrom(const DtxController& from);
  void MergeFrom(const DtxController& from) { DtxController::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DtxController* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.DtxController"; }

 protected:
  explicit DtxController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DtxController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DtxController& from);
  DtxController(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DtxController&& from) noexcept
      : DtxController(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDtxEnablingBandwidthBpsFieldNumber = 1,
    kDtxDisablingBandwidthBpsFieldNumber = 2,
  };
  // optional int32 dtx_enabling_bandwidth_bps = 1;
  bool has_dtx_enabling_bandwidth_bps() const;
  void clear_dtx_enabling_bandwidth_bps() ;
  ::int32_t dtx_enabling_bandwidth_bps() const;
  void set_dtx_enabling_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_dtx_enabling_bandwidth_bps() const;
  void _internal_set_dtx_enabling_bandwidth_bps(::int32_t value);

  public:
  // optional int32 dtx_disabling_bandwidth_bps = 2;
  bool has_dtx_disabling_bandwidth_bps() const;
  void clear_dtx_disabling_bandwidth_bps() ;
  ::int32_t dtx_disabling_bandwidth_bps() const;
  void set_dtx_disabling_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_dtx_disabling_bandwidth_bps() const;
  void _internal_set_dtx_disabling_bandwidth_bps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.DtxController)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DtxController& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t dtx_enabling_bandwidth_bps_;
    ::int32_t dtx_disabling_bandwidth_bps_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<50> DtxController_class_data_;
// -------------------------------------------------------------------

class Controller_ScoringPoint final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.Controller.ScoringPoint) */ {
 public:
  inline Controller_ScoringPoint() : Controller_ScoringPoint(nullptr) {}
  ~Controller_ScoringPoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Controller_ScoringPoint* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Controller_ScoringPoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Controller_ScoringPoint(::google::protobuf::internal::ConstantInitialized);

  inline Controller_ScoringPoint(const Controller_ScoringPoint& from) : Controller_ScoringPoint(nullptr, from) {}
  inline Controller_ScoringPoint(Controller_ScoringPoint&& from) noexcept
      : Controller_ScoringPoint(nullptr, std::move(from)) {}
  inline Controller_ScoringPoint& operator=(const Controller_ScoringPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Controller_ScoringPoint& operator=(Controller_ScoringPoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Controller_ScoringPoint& default_instance() {
    return *reinterpret_cast<const Controller_ScoringPoint*>(
        &_Controller_ScoringPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Controller_ScoringPoint& a, Controller_ScoringPoint& b) { a.Swap(&b); }
  inline void Swap(Controller_ScoringPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Controller_ScoringPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Controller_ScoringPoint* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Controller_ScoringPoint>(arena);
  }
  void CopyFrom(const Controller_ScoringPoint& from);
  void MergeFrom(const Controller_ScoringPoint& from) { Controller_ScoringPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Controller_ScoringPoint* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.Controller.ScoringPoint"; }

 protected:
  explicit Controller_ScoringPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Controller_ScoringPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Controller_ScoringPoint& from);
  Controller_ScoringPoint(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Controller_ScoringPoint&& from) noexcept
      : Controller_ScoringPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUplinkBandwidthBpsFieldNumber = 1,
    kUplinkPacketLossFractionFieldNumber = 2,
  };
  // optional int32 uplink_bandwidth_bps = 1;
  bool has_uplink_bandwidth_bps() const;
  void clear_uplink_bandwidth_bps() ;
  ::int32_t uplink_bandwidth_bps() const;
  void set_uplink_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_uplink_bandwidth_bps() const;
  void _internal_set_uplink_bandwidth_bps(::int32_t value);

  public:
  // optional float uplink_packet_loss_fraction = 2;
  bool has_uplink_packet_loss_fraction() const;
  void clear_uplink_packet_loss_fraction() ;
  float uplink_packet_loss_fraction() const;
  void set_uplink_packet_loss_fraction(float value);

  private:
  float _internal_uplink_packet_loss_fraction() const;
  void _internal_set_uplink_packet_loss_fraction(float value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Controller_ScoringPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t uplink_bandwidth_bps_;
    float uplink_packet_loss_fraction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<60> Controller_ScoringPoint_class_data_;
// -------------------------------------------------------------------

class ChannelController final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.ChannelController) */ {
 public:
  inline ChannelController() : ChannelController(nullptr) {}
  ~ChannelController() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChannelController* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChannelController));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelController(::google::protobuf::internal::ConstantInitialized);

  inline ChannelController(const ChannelController& from) : ChannelController(nullptr, from) {}
  inline ChannelController(ChannelController&& from) noexcept
      : ChannelController(nullptr, std::move(from)) {}
  inline ChannelController& operator=(const ChannelController& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelController& operator=(ChannelController&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChannelController& default_instance() {
    return *reinterpret_cast<const ChannelController*>(
        &_ChannelController_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ChannelController& a, ChannelController& b) { a.Swap(&b); }
  inline void Swap(ChannelController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelController* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ChannelController>(arena);
  }
  void CopyFrom(const ChannelController& from);
  void MergeFrom(const ChannelController& from) { ChannelController::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChannelController* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.ChannelController"; }

 protected:
  explicit ChannelController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChannelController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChannelController& from);
  ChannelController(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChannelController&& from) noexcept
      : ChannelController(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChannel1To2BandwidthBpsFieldNumber = 1,
    kChannel2To1BandwidthBpsFieldNumber = 2,
  };
  // optional int32 channel_1_to_2_bandwidth_bps = 1;
  bool has_channel_1_to_2_bandwidth_bps() const;
  void clear_channel_1_to_2_bandwidth_bps() ;
  ::int32_t channel_1_to_2_bandwidth_bps() const;
  void set_channel_1_to_2_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_channel_1_to_2_bandwidth_bps() const;
  void _internal_set_channel_1_to_2_bandwidth_bps(::int32_t value);

  public:
  // optional int32 channel_2_to_1_bandwidth_bps = 2;
  bool has_channel_2_to_1_bandwidth_bps() const;
  void clear_channel_2_to_1_bandwidth_bps() ;
  ::int32_t channel_2_to_1_bandwidth_bps() const;
  void set_channel_2_to_1_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_channel_2_to_1_bandwidth_bps() const;
  void _internal_set_channel_2_to_1_bandwidth_bps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.ChannelController)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChannelController& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t channel_1_to_2_bandwidth_bps_;
    ::int32_t channel_2_to_1_bandwidth_bps_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<54> ChannelController_class_data_;
// -------------------------------------------------------------------

class BitrateController final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.BitrateController) */ {
 public:
  inline BitrateController() : BitrateController(nullptr) {}
  ~BitrateController() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BitrateController* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BitrateController));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BitrateController(::google::protobuf::internal::ConstantInitialized);

  inline BitrateController(const BitrateController& from) : BitrateController(nullptr, from) {}
  inline BitrateController(BitrateController&& from) noexcept
      : BitrateController(nullptr, std::move(from)) {}
  inline BitrateController& operator=(const BitrateController& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitrateController& operator=(BitrateController&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BitrateController& default_instance() {
    return *reinterpret_cast<const BitrateController*>(
        &_BitrateController_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(BitrateController& a, BitrateController& b) { a.Swap(&b); }
  inline void Swap(BitrateController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitrateController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitrateController* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<BitrateController>(arena);
  }
  void CopyFrom(const BitrateController& from);
  void MergeFrom(const BitrateController& from) { BitrateController::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BitrateController* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.BitrateController"; }

 protected:
  explicit BitrateController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BitrateController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BitrateController& from);
  BitrateController(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BitrateController&& from) noexcept
      : BitrateController(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFlIncreaseOverheadOffsetFieldNumber = 1,
    kFlDecreaseOverheadOffsetFieldNumber = 2,
  };
  // optional int32 fl_increase_overhead_offset = 1;
  bool has_fl_increase_overhead_offset() const;
  void clear_fl_increase_overhead_offset() ;
  ::int32_t fl_increase_overhead_offset() const;
  void set_fl_increase_overhead_offset(::int32_t value);

  private:
  ::int32_t _internal_fl_increase_overhead_offset() const;
  void _internal_set_fl_increase_overhead_offset(::int32_t value);

  public:
  // optional int32 fl_decrease_overhead_offset = 2;
  bool has_fl_decrease_overhead_offset() const;
  void clear_fl_decrease_overhead_offset() ;
  ::int32_t fl_decrease_overhead_offset() const;
  void set_fl_decrease_overhead_offset(::int32_t value);

  private:
  ::int32_t _internal_fl_decrease_overhead_offset() const;
  void _internal_set_fl_decrease_overhead_offset(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.BitrateController)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BitrateController& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t fl_increase_overhead_offset_;
    ::int32_t fl_decrease_overhead_offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<54> BitrateController_class_data_;
// -------------------------------------------------------------------

class FecControllerRplrBased final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecControllerRplrBased) */ {
 public:
  inline FecControllerRplrBased() : FecControllerRplrBased(nullptr) {}
  ~FecControllerRplrBased() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FecControllerRplrBased* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FecControllerRplrBased));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FecControllerRplrBased(::google::protobuf::internal::ConstantInitialized);

  inline FecControllerRplrBased(const FecControllerRplrBased& from) : FecControllerRplrBased(nullptr, from) {}
  inline FecControllerRplrBased(FecControllerRplrBased&& from) noexcept
      : FecControllerRplrBased(nullptr, std::move(from)) {}
  inline FecControllerRplrBased& operator=(const FecControllerRplrBased& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecControllerRplrBased& operator=(FecControllerRplrBased&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FecControllerRplrBased& default_instance() {
    return *reinterpret_cast<const FecControllerRplrBased*>(
        &_FecControllerRplrBased_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(FecControllerRplrBased& a, FecControllerRplrBased& b) { a.Swap(&b); }
  inline void Swap(FecControllerRplrBased* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FecControllerRplrBased* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FecControllerRplrBased* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<FecControllerRplrBased>(arena);
  }
  void CopyFrom(const FecControllerRplrBased& from);
  void MergeFrom(const FecControllerRplrBased& from) { FecControllerRplrBased::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FecControllerRplrBased* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.FecControllerRplrBased"; }

 protected:
  explicit FecControllerRplrBased(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FecControllerRplrBased(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FecControllerRplrBased& from);
  FecControllerRplrBased(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FecControllerRplrBased&& from) noexcept
      : FecControllerRplrBased(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------
  using Threshold = FecControllerRplrBased_Threshold;

  // accessors -------------------------------------------------------
  enum : int {
    kFecEnablingThresholdFieldNumber = 1,
    kFecDisablingThresholdFieldNumber = 2,
  };
  // optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_enabling_threshold = 1;
  bool has_fec_enabling_threshold() const;
  void clear_fec_enabling_threshold() ;
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& fec_enabling_threshold() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE release_fec_enabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NONNULL mutable_fec_enabling_threshold();
  void set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE unsafe_arena_release_fec_enabling_threshold();

  private:
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& _internal_fec_enabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NONNULL _internal_mutable_fec_enabling_threshold();

  public:
  // optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_disabling_threshold = 2;
  bool has_fec_disabling_threshold() const;
  void clear_fec_disabling_threshold() ;
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& fec_disabling_threshold() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE release_fec_disabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NONNULL mutable_fec_disabling_threshold();
  void set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE unsafe_arena_release_fec_disabling_threshold();

  private:
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& _internal_fec_disabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NONNULL _internal_mutable_fec_disabling_threshold();

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecControllerRplrBased)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FecControllerRplrBased& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE fec_enabling_threshold_;
    ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE fec_disabling_threshold_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<59> FecControllerRplrBased_class_data_;
// -------------------------------------------------------------------

class FecController final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecController) */ {
 public:
  inline FecController() : FecController(nullptr) {}
  ~FecController() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FecController* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FecController));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FecController(::google::protobuf::internal::ConstantInitialized);

  inline FecController(const FecController& from) : FecController(nullptr, from) {}
  inline FecController(FecController&& from) noexcept
      : FecController(nullptr, std::move(from)) {}
  inline FecController& operator=(const FecController& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecController& operator=(FecController&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FecController& default_instance() {
    return *reinterpret_cast<const FecController*>(
        &_FecController_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(FecController& a, FecController& b) { a.Swap(&b); }
  inline void Swap(FecController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FecController* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FecController* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<FecController>(arena);
  }
  void CopyFrom(const FecController& from);
  void MergeFrom(const FecController& from) { FecController::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FecController* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.FecController"; }

 protected:
  explicit FecController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FecController(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FecController& from);
  FecController(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FecController&& from) noexcept
      : FecController(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------
  using Threshold = FecController_Threshold;

  // accessors -------------------------------------------------------
  enum : int {
    kFecEnablingThresholdFieldNumber = 1,
    kFecDisablingThresholdFieldNumber = 2,
    kTimeConstantMsFieldNumber = 3,
  };
  // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
  bool has_fec_enabling_threshold() const;
  void clear_fec_enabling_threshold() ;
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& fec_enabling_threshold() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE release_fec_enabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NONNULL mutable_fec_enabling_threshold();
  void set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE unsafe_arena_release_fec_enabling_threshold();

  private:
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& _internal_fec_enabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NONNULL _internal_mutable_fec_enabling_threshold();

  public:
  // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
  bool has_fec_disabling_threshold() const;
  void clear_fec_disabling_threshold() ;
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& fec_disabling_threshold() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE release_fec_disabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NONNULL mutable_fec_disabling_threshold();
  void set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE unsafe_arena_release_fec_disabling_threshold();

  private:
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& _internal_fec_disabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NONNULL _internal_mutable_fec_disabling_threshold();

  public:
  // optional int32 time_constant_ms = 3;
  bool has_time_constant_ms() const;
  void clear_time_constant_ms() ;
  ::int32_t time_constant_ms() const;
  void set_time_constant_ms(::int32_t value);

  private:
  ::int32_t _internal_time_constant_ms() const;
  void _internal_set_time_constant_ms(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecController)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FecController& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE fec_enabling_threshold_;
    ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE fec_disabling_threshold_;
    ::int32_t time_constant_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<50> FecController_class_data_;
// -------------------------------------------------------------------

class Controller final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.Controller) */ {
 public:
  inline Controller() : Controller(nullptr) {}
  ~Controller() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Controller* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Controller));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Controller(::google::protobuf::internal::ConstantInitialized);

  inline Controller(const Controller& from) : Controller(nullptr, from) {}
  inline Controller(Controller&& from) noexcept
      : Controller(nullptr, std::move(from)) {}
  inline Controller& operator=(const Controller& from) {
    CopyFrom(from);
    return *this;
  }
  inline Controller& operator=(Controller&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Controller& default_instance() {
    return *reinterpret_cast<const Controller*>(
        &_Controller_default_instance_);
  }
  enum ControllerCase {
    kFecController = 21,
    kFrameLengthController = 22,
    kChannelController = 23,
    kDtxController = 24,
    kBitrateController = 25,
    kFecControllerRplrBased = 26,
    kFrameLengthControllerV2 = 27,
    CONTROLLER_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Controller& a, Controller& b) { a.Swap(&b); }
  inline void Swap(Controller* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Controller* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Controller* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Controller>(arena);
  }
  void CopyFrom(const Controller& from);
  void MergeFrom(const Controller& from) { Controller::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Controller* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.Controller"; }

 protected:
  explicit Controller(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Controller(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Controller& from);
  Controller(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Controller&& from) noexcept
      : Controller(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------
  using ScoringPoint = Controller_ScoringPoint;

  // accessors -------------------------------------------------------
  enum : int {
    kScoringPointFieldNumber = 1,
    kFecControllerFieldNumber = 21,
    kFrameLengthControllerFieldNumber = 22,
    kChannelControllerFieldNumber = 23,
    kDtxControllerFieldNumber = 24,
    kBitrateControllerFieldNumber = 25,
    kFecControllerRplrBasedFieldNumber = 26,
    kFrameLengthControllerV2FieldNumber = 27,
  };
  // optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
  bool has_scoring_point() const;
  void clear_scoring_point() ;
  const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& scoring_point() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NULLABLE release_scoring_point();
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NONNULL mutable_scoring_point();
  void set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NULLABLE unsafe_arena_release_scoring_point();

  private:
  const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& _internal_scoring_point() const;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NONNULL _internal_mutable_scoring_point();

  public:
  // .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
  bool has_fec_controller() const;
  private:
  bool _internal_has_fec_controller() const;

  public:
  void clear_fec_controller() ;
  const ::webrtc::audio_network_adaptor::config::FecController& fec_controller() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NULLABLE release_fec_controller();
  ::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NONNULL mutable_fec_controller();
  void set_allocated_fec_controller(::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fec_controller(::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NULLABLE unsafe_arena_release_fec_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::FecController& _internal_fec_controller() const;
  ::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NONNULL _internal_mutable_fec_controller();

  public:
  // .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
  bool has_frame_length_controller() const;
  private:
  bool _internal_has_frame_length_controller() const;

  public:
  void clear_frame_length_controller() ;
  const ::webrtc::audio_network_adaptor::config::FrameLengthController& frame_length_controller() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NULLABLE release_frame_length_controller();
  ::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NONNULL mutable_frame_length_controller();
  void set_allocated_frame_length_controller(::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_frame_length_controller(::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NULLABLE unsafe_arena_release_frame_length_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::FrameLengthController& _internal_frame_length_controller() const;
  ::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NONNULL _internal_mutable_frame_length_controller();

  public:
  // .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
  bool has_channel_controller() const;
  private:
  bool _internal_has_channel_controller() const;

  public:
  void clear_channel_controller() ;
  const ::webrtc::audio_network_adaptor::config::ChannelController& channel_controller() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NULLABLE release_channel_controller();
  ::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NONNULL mutable_channel_controller();
  void set_allocated_channel_controller(::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_channel_controller(::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NULLABLE unsafe_arena_release_channel_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::ChannelController& _internal_channel_controller() const;
  ::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NONNULL _internal_mutable_channel_controller();

  public:
  // .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
  bool has_dtx_controller() const;
  private:
  bool _internal_has_dtx_controller() const;

  public:
  void clear_dtx_controller() ;
  const ::webrtc::audio_network_adaptor::config::DtxController& dtx_controller() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NULLABLE release_dtx_controller();
  ::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NONNULL mutable_dtx_controller();
  void set_allocated_dtx_controller(::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dtx_controller(::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NULLABLE unsafe_arena_release_dtx_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::DtxController& _internal_dtx_controller() const;
  ::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NONNULL _internal_mutable_dtx_controller();

  public:
  // .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
  bool has_bitrate_controller() const;
  private:
  bool _internal_has_bitrate_controller() const;

  public:
  void clear_bitrate_controller() ;
  const ::webrtc::audio_network_adaptor::config::BitrateController& bitrate_controller() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NULLABLE release_bitrate_controller();
  ::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NONNULL mutable_bitrate_controller();
  void set_allocated_bitrate_controller(::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bitrate_controller(::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NULLABLE unsafe_arena_release_bitrate_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::BitrateController& _internal_bitrate_controller() const;
  ::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NONNULL _internal_mutable_bitrate_controller();

  public:
  // .webrtc.audio_network_adaptor.config.FecControllerRplrBased fec_controller_rplr_based = 26;
  bool has_fec_controller_rplr_based() const;
  private:
  bool _internal_has_fec_controller_rplr_based() const;

  public:
  void clear_fec_controller_rplr_based() ;
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& fec_controller_rplr_based() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NULLABLE release_fec_controller_rplr_based();
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NONNULL mutable_fec_controller_rplr_based();
  void set_allocated_fec_controller_rplr_based(::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fec_controller_rplr_based(::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NULLABLE unsafe_arena_release_fec_controller_rplr_based();

  private:
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& _internal_fec_controller_rplr_based() const;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NONNULL _internal_mutable_fec_controller_rplr_based();

  public:
  // .webrtc.audio_network_adaptor.config.FrameLengthControllerV2 frame_length_controller_v2 = 27;
  bool has_frame_length_controller_v2() const;
  private:
  bool _internal_has_frame_length_controller_v2() const;

  public:
  void clear_frame_length_controller_v2() ;
  const ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2& frame_length_controller_v2() const;
  [[nodiscard]] ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NULLABLE release_frame_length_controller_v2();
  ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NONNULL mutable_frame_length_controller_v2();
  void set_allocated_frame_length_controller_v2(::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_frame_length_controller_v2(::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NULLABLE value);
  ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NULLABLE unsafe_arena_release_frame_length_controller_v2();

  private:
  const ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2& _internal_frame_length_controller_v2() const;
  ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NONNULL _internal_mutable_frame_length_controller_v2();

  public:
  void clear_controller();
  ControllerCase controller_case() const;
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.Controller)
 private:
  class _Internal;
  void set_has_fec_controller();
  void set_has_frame_length_controller();
  void set_has_channel_controller();
  void set_has_dtx_controller();
  void set_has_bitrate_controller();
  void set_has_fec_controller_rplr_based();
  void set_has_frame_length_controller_v2();
  inline bool has_controller() const;
  inline void clear_has_controller();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 8,
                                   8, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Controller& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NULLABLE scoring_point_;
    union ControllerUnion {
      constexpr ControllerUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE fec_controller_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE frame_length_controller_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE channel_controller_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE dtx_controller_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE bitrate_controller_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE fec_controller_rplr_based_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE frame_length_controller_v2_;
    } controller_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<47> Controller_class_data_;
// -------------------------------------------------------------------

class ControllerManager final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.ControllerManager) */ {
 public:
  inline ControllerManager() : ControllerManager(nullptr) {}
  ~ControllerManager() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ControllerManager* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ControllerManager));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerManager(::google::protobuf::internal::ConstantInitialized);

  inline ControllerManager(const ControllerManager& from) : ControllerManager(nullptr, from) {}
  inline ControllerManager(ControllerManager&& from) noexcept
      : ControllerManager(nullptr, std::move(from)) {}
  inline ControllerManager& operator=(const ControllerManager& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerManager& operator=(ControllerManager&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ControllerManager& default_instance() {
    return *reinterpret_cast<const ControllerManager*>(
        &_ControllerManager_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ControllerManager& a, ControllerManager& b) { a.Swap(&b); }
  inline void Swap(ControllerManager* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerManager* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerManager* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ControllerManager>(arena);
  }
  void CopyFrom(const ControllerManager& from);
  void MergeFrom(const ControllerManager& from) { ControllerManager::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ControllerManager* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "webrtc.audio_network_adaptor.config.ControllerManager"; }

 protected:
  explicit ControllerManager(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ControllerManager(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ControllerManager& from);
  ControllerManager(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ControllerManager&& from) noexcept
      : ControllerManager(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControllersFieldNumber = 1,
    kMinReorderingTimeMsFieldNumber = 2,
    kMinReorderingSquaredDistanceFieldNumber = 3,
  };
  // repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
  int controllers_size() const;
  private:
  int _internal_controllers_size() const;

  public:
  void clear_controllers() ;
  ::webrtc::audio_network_adaptor::config::Controller* PROTOBUF_NONNULL mutable_controllers(int index);
  ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>* PROTOBUF_NONNULL mutable_controllers();

  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>& _internal_controllers() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>* PROTOBUF_NONNULL _internal_mutable_controllers();
  public:
  const ::webrtc::audio_network_adaptor::config::Controller& controllers(int index) const;
  ::webrtc::audio_network_adaptor::config::Controller* PROTOBUF_NONNULL add_controllers();
  const ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>& controllers() const;
  // optional int32 min_reordering_time_ms = 2;
  bool has_min_reordering_time_ms() const;
  void clear_min_reordering_time_ms() ;
  ::int32_t min_reordering_time_ms() const;
  void set_min_reordering_time_ms(::int32_t value);

  private:
  ::int32_t _internal_min_reordering_time_ms() const;
  void _internal_set_min_reordering_time_ms(::int32_t value);

  public:
  // optional float min_reordering_squared_distance = 3;
  bool has_min_reordering_squared_distance() const;
  void clear_min_reordering_squared_distance() ;
  float min_reordering_squared_distance() const;
  void set_min_reordering_squared_distance(float value);

  private:
  float _internal_min_reordering_squared_distance() const;
  void _internal_set_min_reordering_squared_distance(float value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.ControllerManager)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ControllerManager& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::audio_network_adaptor::config::Controller > controllers_;
    ::int32_t min_reordering_time_ms_;
    float min_reordering_squared_distance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<54> ControllerManager_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FecController_Threshold

// optional int32 low_bandwidth_bps = 1;
inline bool FecController_Threshold::has_low_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FecController_Threshold::clear_low_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t FecController_Threshold::low_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_bps)
  return _internal_low_bandwidth_bps();
}
inline void FecController_Threshold::set_low_bandwidth_bps(::int32_t value) {
  _internal_set_low_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_bps)
}
inline ::int32_t FecController_Threshold::_internal_low_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.low_bandwidth_bps_;
}
inline void FecController_Threshold::_internal_set_low_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_bandwidth_bps_ = value;
}

// optional float low_bandwidth_packet_loss = 2;
inline bool FecController_Threshold::has_low_bandwidth_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FecController_Threshold::clear_low_bandwidth_packet_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_bandwidth_packet_loss_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FecController_Threshold::low_bandwidth_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_packet_loss)
  return _internal_low_bandwidth_packet_loss();
}
inline void FecController_Threshold::set_low_bandwidth_packet_loss(float value) {
  _internal_set_low_bandwidth_packet_loss(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_packet_loss)
}
inline float FecController_Threshold::_internal_low_bandwidth_packet_loss() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.low_bandwidth_packet_loss_;
}
inline void FecController_Threshold::_internal_set_low_bandwidth_packet_loss(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_bandwidth_packet_loss_ = value;
}

// optional int32 high_bandwidth_bps = 3;
inline bool FecController_Threshold::has_high_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FecController_Threshold::clear_high_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t FecController_Threshold::high_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_bps)
  return _internal_high_bandwidth_bps();
}
inline void FecController_Threshold::set_high_bandwidth_bps(::int32_t value) {
  _internal_set_high_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_bps)
}
inline ::int32_t FecController_Threshold::_internal_high_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.high_bandwidth_bps_;
}
inline void FecController_Threshold::_internal_set_high_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_bandwidth_bps_ = value;
}

// optional float high_bandwidth_packet_loss = 4;
inline bool FecController_Threshold::has_high_bandwidth_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FecController_Threshold::clear_high_bandwidth_packet_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_bandwidth_packet_loss_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float FecController_Threshold::high_bandwidth_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_packet_loss)
  return _internal_high_bandwidth_packet_loss();
}
inline void FecController_Threshold::set_high_bandwidth_packet_loss(float value) {
  _internal_set_high_bandwidth_packet_loss(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_packet_loss)
}
inline float FecController_Threshold::_internal_high_bandwidth_packet_loss() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.high_bandwidth_packet_loss_;
}
inline void FecController_Threshold::_internal_set_high_bandwidth_packet_loss(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_bandwidth_packet_loss_ = value;
}

// -------------------------------------------------------------------

// FecController

// optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
inline bool FecController::has_fec_enabling_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_enabling_threshold_ != nullptr);
  return value;
}
inline void FecController::clear_fec_enabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_enabling_threshold_ != nullptr) _impl_.fec_enabling_threshold_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::_internal_fec_enabling_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold* p = _impl_.fec_enabling_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecController_Threshold&>(::webrtc::audio_network_adaptor::config::_FecController_Threshold_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::fec_enabling_threshold() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
  return _internal_fec_enabling_threshold();
}
inline void FecController::unsafe_arena_set_allocated_fec_enabling_threshold(
    ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_enabling_threshold_);
  }
  _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE FecController::release_fec_enabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* released = _impl_.fec_enabling_threshold_;
  _impl_.fec_enabling_threshold_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE FecController::unsafe_arena_release_fec_enabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* temp = _impl_.fec_enabling_threshold_;
  _impl_.fec_enabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NONNULL FecController::_internal_mutable_fec_enabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_enabling_threshold_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::FecController_Threshold>(GetArena());
    _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(p);
  }
  return _impl_.fec_enabling_threshold_;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NONNULL FecController::mutable_fec_enabling_threshold()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* _msg = _internal_mutable_fec_enabling_threshold();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
  return _msg;
}
inline void FecController::set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_enabling_threshold_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
}

// optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
inline bool FecController::has_fec_disabling_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_disabling_threshold_ != nullptr);
  return value;
}
inline void FecController::clear_fec_disabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_disabling_threshold_ != nullptr) _impl_.fec_disabling_threshold_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::_internal_fec_disabling_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold* p = _impl_.fec_disabling_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecController_Threshold&>(::webrtc::audio_network_adaptor::config::_FecController_Threshold_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::fec_disabling_threshold() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
  return _internal_fec_disabling_threshold();
}
inline void FecController::unsafe_arena_set_allocated_fec_disabling_threshold(
    ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_disabling_threshold_);
  }
  _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE FecController::release_fec_disabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* released = _impl_.fec_disabling_threshold_;
  _impl_.fec_disabling_threshold_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE FecController::unsafe_arena_release_fec_disabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* temp = _impl_.fec_disabling_threshold_;
  _impl_.fec_disabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NONNULL FecController::_internal_mutable_fec_disabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_disabling_threshold_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::FecController_Threshold>(GetArena());
    _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(p);
  }
  return _impl_.fec_disabling_threshold_;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NONNULL FecController::mutable_fec_disabling_threshold()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* _msg = _internal_mutable_fec_disabling_threshold();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
  return _msg;
}
inline void FecController::set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_disabling_threshold_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
}

// optional int32 time_constant_ms = 3;
inline bool FecController::has_time_constant_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FecController::clear_time_constant_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_constant_ms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t FecController::time_constant_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.time_constant_ms)
  return _internal_time_constant_ms();
}
inline void FecController::set_time_constant_ms(::int32_t value) {
  _internal_set_time_constant_ms(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.time_constant_ms)
}
inline ::int32_t FecController::_internal_time_constant_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_constant_ms_;
}
inline void FecController::_internal_set_time_constant_ms(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_constant_ms_ = value;
}

// -------------------------------------------------------------------

// FecControllerRplrBased_Threshold

// optional int32 low_bandwidth_bps = 1;
inline bool FecControllerRplrBased_Threshold::has_low_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FecControllerRplrBased_Threshold::clear_low_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t FecControllerRplrBased_Threshold::low_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_bps)
  return _internal_low_bandwidth_bps();
}
inline void FecControllerRplrBased_Threshold::set_low_bandwidth_bps(::int32_t value) {
  _internal_set_low_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_bps)
}
inline ::int32_t FecControllerRplrBased_Threshold::_internal_low_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.low_bandwidth_bps_;
}
inline void FecControllerRplrBased_Threshold::_internal_set_low_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_bandwidth_bps_ = value;
}

// optional float low_bandwidth_recoverable_packet_loss = 2;
inline bool FecControllerRplrBased_Threshold::has_low_bandwidth_recoverable_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FecControllerRplrBased_Threshold::clear_low_bandwidth_recoverable_packet_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_bandwidth_recoverable_packet_loss_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FecControllerRplrBased_Threshold::low_bandwidth_recoverable_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_recoverable_packet_loss)
  return _internal_low_bandwidth_recoverable_packet_loss();
}
inline void FecControllerRplrBased_Threshold::set_low_bandwidth_recoverable_packet_loss(float value) {
  _internal_set_low_bandwidth_recoverable_packet_loss(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_recoverable_packet_loss)
}
inline float FecControllerRplrBased_Threshold::_internal_low_bandwidth_recoverable_packet_loss() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.low_bandwidth_recoverable_packet_loss_;
}
inline void FecControllerRplrBased_Threshold::_internal_set_low_bandwidth_recoverable_packet_loss(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_bandwidth_recoverable_packet_loss_ = value;
}

// optional int32 high_bandwidth_bps = 3;
inline bool FecControllerRplrBased_Threshold::has_high_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FecControllerRplrBased_Threshold::clear_high_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t FecControllerRplrBased_Threshold::high_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_bps)
  return _internal_high_bandwidth_bps();
}
inline void FecControllerRplrBased_Threshold::set_high_bandwidth_bps(::int32_t value) {
  _internal_set_high_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_bps)
}
inline ::int32_t FecControllerRplrBased_Threshold::_internal_high_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.high_bandwidth_bps_;
}
inline void FecControllerRplrBased_Threshold::_internal_set_high_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_bandwidth_bps_ = value;
}

// optional float high_bandwidth_recoverable_packet_loss = 4;
inline bool FecControllerRplrBased_Threshold::has_high_bandwidth_recoverable_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FecControllerRplrBased_Threshold::clear_high_bandwidth_recoverable_packet_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_bandwidth_recoverable_packet_loss_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float FecControllerRplrBased_Threshold::high_bandwidth_recoverable_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_recoverable_packet_loss)
  return _internal_high_bandwidth_recoverable_packet_loss();
}
inline void FecControllerRplrBased_Threshold::set_high_bandwidth_recoverable_packet_loss(float value) {
  _internal_set_high_bandwidth_recoverable_packet_loss(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_recoverable_packet_loss)
}
inline float FecControllerRplrBased_Threshold::_internal_high_bandwidth_recoverable_packet_loss() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.high_bandwidth_recoverable_packet_loss_;
}
inline void FecControllerRplrBased_Threshold::_internal_set_high_bandwidth_recoverable_packet_loss(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_bandwidth_recoverable_packet_loss_ = value;
}

// -------------------------------------------------------------------

// FecControllerRplrBased

// optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_enabling_threshold = 1;
inline bool FecControllerRplrBased::has_fec_enabling_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_enabling_threshold_ != nullptr);
  return value;
}
inline void FecControllerRplrBased::clear_fec_enabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_enabling_threshold_ != nullptr) _impl_.fec_enabling_threshold_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::_internal_fec_enabling_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* p = _impl_.fec_enabling_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold&>(::webrtc::audio_network_adaptor::config::_FecControllerRplrBased_Threshold_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::fec_enabling_threshold() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
  return _internal_fec_enabling_threshold();
}
inline void FecControllerRplrBased::unsafe_arena_set_allocated_fec_enabling_threshold(
    ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_enabling_threshold_);
  }
  _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE FecControllerRplrBased::release_fec_enabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* released = _impl_.fec_enabling_threshold_;
  _impl_.fec_enabling_threshold_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE FecControllerRplrBased::unsafe_arena_release_fec_enabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* temp = _impl_.fec_enabling_threshold_;
  _impl_.fec_enabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NONNULL FecControllerRplrBased::_internal_mutable_fec_enabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_enabling_threshold_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold>(GetArena());
    _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(p);
  }
  return _impl_.fec_enabling_threshold_;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NONNULL FecControllerRplrBased::mutable_fec_enabling_threshold()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* _msg = _internal_mutable_fec_enabling_threshold();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
  return _msg;
}
inline void FecControllerRplrBased::set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_enabling_threshold_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
}

// optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_disabling_threshold = 2;
inline bool FecControllerRplrBased::has_fec_disabling_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_disabling_threshold_ != nullptr);
  return value;
}
inline void FecControllerRplrBased::clear_fec_disabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_disabling_threshold_ != nullptr) _impl_.fec_disabling_threshold_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::_internal_fec_disabling_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* p = _impl_.fec_disabling_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold&>(::webrtc::audio_network_adaptor::config::_FecControllerRplrBased_Threshold_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::fec_disabling_threshold() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
  return _internal_fec_disabling_threshold();
}
inline void FecControllerRplrBased::unsafe_arena_set_allocated_fec_disabling_threshold(
    ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_disabling_threshold_);
  }
  _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE FecControllerRplrBased::release_fec_disabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* released = _impl_.fec_disabling_threshold_;
  _impl_.fec_disabling_threshold_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE FecControllerRplrBased::unsafe_arena_release_fec_disabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* temp = _impl_.fec_disabling_threshold_;
  _impl_.fec_disabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NONNULL FecControllerRplrBased::_internal_mutable_fec_disabling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_disabling_threshold_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold>(GetArena());
    _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(p);
  }
  return _impl_.fec_disabling_threshold_;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NONNULL FecControllerRplrBased::mutable_fec_disabling_threshold()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* _msg = _internal_mutable_fec_disabling_threshold();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
  return _msg;
}
inline void FecControllerRplrBased::set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_disabling_threshold_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
}

// -------------------------------------------------------------------

// FrameLengthController

// optional float fl_increasing_packet_loss_fraction = 1;
inline bool FrameLengthController::has_fl_increasing_packet_loss_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_increasing_packet_loss_fraction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_increasing_packet_loss_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float FrameLengthController::fl_increasing_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increasing_packet_loss_fraction)
  return _internal_fl_increasing_packet_loss_fraction();
}
inline void FrameLengthController::set_fl_increasing_packet_loss_fraction(float value) {
  _internal_set_fl_increasing_packet_loss_fraction(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increasing_packet_loss_fraction)
}
inline float FrameLengthController::_internal_fl_increasing_packet_loss_fraction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_increasing_packet_loss_fraction_;
}
inline void FrameLengthController::_internal_set_fl_increasing_packet_loss_fraction(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_increasing_packet_loss_fraction_ = value;
}

// optional float fl_decreasing_packet_loss_fraction = 2;
inline bool FrameLengthController::has_fl_decreasing_packet_loss_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_decreasing_packet_loss_fraction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_decreasing_packet_loss_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FrameLengthController::fl_decreasing_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decreasing_packet_loss_fraction)
  return _internal_fl_decreasing_packet_loss_fraction();
}
inline void FrameLengthController::set_fl_decreasing_packet_loss_fraction(float value) {
  _internal_set_fl_decreasing_packet_loss_fraction(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decreasing_packet_loss_fraction)
}
inline float FrameLengthController::_internal_fl_decreasing_packet_loss_fraction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_decreasing_packet_loss_fraction_;
}
inline void FrameLengthController::_internal_set_fl_decreasing_packet_loss_fraction(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_decreasing_packet_loss_fraction_ = value;
}

// optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
inline bool FrameLengthController::has_fl_20ms_to_60ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_20ms_to_60ms_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_20ms_to_60ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t FrameLengthController::fl_20ms_to_60ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_60ms_bandwidth_bps)
  return _internal_fl_20ms_to_60ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_20ms_to_60ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_20ms_to_60ms_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_60ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_20ms_to_60ms_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_20ms_to_60ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_20ms_to_60ms_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_20ms_to_60ms_bandwidth_bps_ = value;
}

// optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
inline bool FrameLengthController::has_fl_60ms_to_20ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_60ms_to_20ms_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_60ms_to_20ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t FrameLengthController::fl_60ms_to_20ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_20ms_bandwidth_bps)
  return _internal_fl_60ms_to_20ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_60ms_to_20ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_60ms_to_20ms_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_20ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_60ms_to_20ms_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_60ms_to_20ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_60ms_to_20ms_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_60ms_to_20ms_bandwidth_bps_ = value;
}

// optional int32 fl_60ms_to_120ms_bandwidth_bps = 5;
inline bool FrameLengthController::has_fl_60ms_to_120ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_60ms_to_120ms_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_60ms_to_120ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t FrameLengthController::fl_60ms_to_120ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_120ms_bandwidth_bps)
  return _internal_fl_60ms_to_120ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_60ms_to_120ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_60ms_to_120ms_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_120ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_60ms_to_120ms_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_60ms_to_120ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_60ms_to_120ms_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_60ms_to_120ms_bandwidth_bps_ = value;
}

// optional int32 fl_120ms_to_60ms_bandwidth_bps = 6;
inline bool FrameLengthController::has_fl_120ms_to_60ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_120ms_to_60ms_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_120ms_to_60ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t FrameLengthController::fl_120ms_to_60ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_120ms_to_60ms_bandwidth_bps)
  return _internal_fl_120ms_to_60ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_120ms_to_60ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_120ms_to_60ms_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_120ms_to_60ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_120ms_to_60ms_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_120ms_to_60ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_120ms_to_60ms_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_120ms_to_60ms_bandwidth_bps_ = value;
}

// optional int32 fl_increase_overhead_offset = 7;
inline bool FrameLengthController::has_fl_increase_overhead_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_increase_overhead_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_increase_overhead_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t FrameLengthController::fl_increase_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increase_overhead_offset)
  return _internal_fl_increase_overhead_offset();
}
inline void FrameLengthController::set_fl_increase_overhead_offset(::int32_t value) {
  _internal_set_fl_increase_overhead_offset(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increase_overhead_offset)
}
inline ::int32_t FrameLengthController::_internal_fl_increase_overhead_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_increase_overhead_offset_;
}
inline void FrameLengthController::_internal_set_fl_increase_overhead_offset(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_increase_overhead_offset_ = value;
}

// optional int32 fl_decrease_overhead_offset = 8;
inline bool FrameLengthController::has_fl_decrease_overhead_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_decrease_overhead_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_decrease_overhead_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t FrameLengthController::fl_decrease_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decrease_overhead_offset)
  return _internal_fl_decrease_overhead_offset();
}
inline void FrameLengthController::set_fl_decrease_overhead_offset(::int32_t value) {
  _internal_set_fl_decrease_overhead_offset(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decrease_overhead_offset)
}
inline ::int32_t FrameLengthController::_internal_fl_decrease_overhead_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_decrease_overhead_offset_;
}
inline void FrameLengthController::_internal_set_fl_decrease_overhead_offset(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_decrease_overhead_offset_ = value;
}

// optional int32 fl_20ms_to_40ms_bandwidth_bps = 9;
inline bool FrameLengthController::has_fl_20ms_to_40ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_20ms_to_40ms_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_20ms_to_40ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t FrameLengthController::fl_20ms_to_40ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_40ms_bandwidth_bps)
  return _internal_fl_20ms_to_40ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_20ms_to_40ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_20ms_to_40ms_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_40ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_20ms_to_40ms_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_20ms_to_40ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_20ms_to_40ms_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_20ms_to_40ms_bandwidth_bps_ = value;
}

// optional int32 fl_40ms_to_20ms_bandwidth_bps = 10;
inline bool FrameLengthController::has_fl_40ms_to_20ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_40ms_to_20ms_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_40ms_to_20ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t FrameLengthController::fl_40ms_to_20ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_20ms_bandwidth_bps)
  return _internal_fl_40ms_to_20ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_40ms_to_20ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_40ms_to_20ms_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_20ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_40ms_to_20ms_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_40ms_to_20ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_40ms_to_20ms_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_40ms_to_20ms_bandwidth_bps_ = value;
}

// optional int32 fl_40ms_to_60ms_bandwidth_bps = 11;
inline bool FrameLengthController::has_fl_40ms_to_60ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_40ms_to_60ms_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_40ms_to_60ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t FrameLengthController::fl_40ms_to_60ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_60ms_bandwidth_bps)
  return _internal_fl_40ms_to_60ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_40ms_to_60ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_40ms_to_60ms_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_60ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_40ms_to_60ms_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_40ms_to_60ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_40ms_to_60ms_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_40ms_to_60ms_bandwidth_bps_ = value;
}

// optional int32 fl_60ms_to_40ms_bandwidth_bps = 12;
inline bool FrameLengthController::has_fl_60ms_to_40ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_60ms_to_40ms_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_60ms_to_40ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t FrameLengthController::fl_60ms_to_40ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_40ms_bandwidth_bps)
  return _internal_fl_60ms_to_40ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_60ms_to_40ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_60ms_to_40ms_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_40ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_60ms_to_40ms_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_60ms_to_40ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_60ms_to_40ms_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_60ms_to_40ms_bandwidth_bps_ = value;
}

// -------------------------------------------------------------------

// FrameLengthControllerV2

// optional int32 min_payload_bitrate_bps = 1;
inline bool FrameLengthControllerV2::has_min_payload_bitrate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FrameLengthControllerV2::clear_min_payload_bitrate_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_payload_bitrate_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t FrameLengthControllerV2::min_payload_bitrate_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthControllerV2.min_payload_bitrate_bps)
  return _internal_min_payload_bitrate_bps();
}
inline void FrameLengthControllerV2::set_min_payload_bitrate_bps(::int32_t value) {
  _internal_set_min_payload_bitrate_bps(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthControllerV2.min_payload_bitrate_bps)
}
inline ::int32_t FrameLengthControllerV2::_internal_min_payload_bitrate_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_payload_bitrate_bps_;
}
inline void FrameLengthControllerV2::_internal_set_min_payload_bitrate_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_payload_bitrate_bps_ = value;
}

// optional bool use_slow_adaptation = 2;
inline bool FrameLengthControllerV2::has_use_slow_adaptation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FrameLengthControllerV2::clear_use_slow_adaptation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_slow_adaptation_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FrameLengthControllerV2::use_slow_adaptation() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthControllerV2.use_slow_adaptation)
  return _internal_use_slow_adaptation();
}
inline void FrameLengthControllerV2::set_use_slow_adaptation(bool value) {
  _internal_set_use_slow_adaptation(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthControllerV2.use_slow_adaptation)
}
inline bool FrameLengthControllerV2::_internal_use_slow_adaptation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.use_slow_adaptation_;
}
inline void FrameLengthControllerV2::_internal_set_use_slow_adaptation(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_slow_adaptation_ = value;
}

// -------------------------------------------------------------------

// ChannelController

// optional int32 channel_1_to_2_bandwidth_bps = 1;
inline bool ChannelController::has_channel_1_to_2_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelController::clear_channel_1_to_2_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_1_to_2_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ChannelController::channel_1_to_2_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ChannelController.channel_1_to_2_bandwidth_bps)
  return _internal_channel_1_to_2_bandwidth_bps();
}
inline void ChannelController::set_channel_1_to_2_bandwidth_bps(::int32_t value) {
  _internal_set_channel_1_to_2_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ChannelController.channel_1_to_2_bandwidth_bps)
}
inline ::int32_t ChannelController::_internal_channel_1_to_2_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_1_to_2_bandwidth_bps_;
}
inline void ChannelController::_internal_set_channel_1_to_2_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_1_to_2_bandwidth_bps_ = value;
}

// optional int32 channel_2_to_1_bandwidth_bps = 2;
inline bool ChannelController::has_channel_2_to_1_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelController::clear_channel_2_to_1_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_2_to_1_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ChannelController::channel_2_to_1_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ChannelController.channel_2_to_1_bandwidth_bps)
  return _internal_channel_2_to_1_bandwidth_bps();
}
inline void ChannelController::set_channel_2_to_1_bandwidth_bps(::int32_t value) {
  _internal_set_channel_2_to_1_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ChannelController.channel_2_to_1_bandwidth_bps)
}
inline ::int32_t ChannelController::_internal_channel_2_to_1_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_2_to_1_bandwidth_bps_;
}
inline void ChannelController::_internal_set_channel_2_to_1_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_2_to_1_bandwidth_bps_ = value;
}

// -------------------------------------------------------------------

// DtxController

// optional int32 dtx_enabling_bandwidth_bps = 1;
inline bool DtxController::has_dtx_enabling_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DtxController::clear_dtx_enabling_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtx_enabling_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t DtxController::dtx_enabling_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.DtxController.dtx_enabling_bandwidth_bps)
  return _internal_dtx_enabling_bandwidth_bps();
}
inline void DtxController::set_dtx_enabling_bandwidth_bps(::int32_t value) {
  _internal_set_dtx_enabling_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.DtxController.dtx_enabling_bandwidth_bps)
}
inline ::int32_t DtxController::_internal_dtx_enabling_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dtx_enabling_bandwidth_bps_;
}
inline void DtxController::_internal_set_dtx_enabling_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtx_enabling_bandwidth_bps_ = value;
}

// optional int32 dtx_disabling_bandwidth_bps = 2;
inline bool DtxController::has_dtx_disabling_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DtxController::clear_dtx_disabling_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtx_disabling_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t DtxController::dtx_disabling_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.DtxController.dtx_disabling_bandwidth_bps)
  return _internal_dtx_disabling_bandwidth_bps();
}
inline void DtxController::set_dtx_disabling_bandwidth_bps(::int32_t value) {
  _internal_set_dtx_disabling_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.DtxController.dtx_disabling_bandwidth_bps)
}
inline ::int32_t DtxController::_internal_dtx_disabling_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dtx_disabling_bandwidth_bps_;
}
inline void DtxController::_internal_set_dtx_disabling_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtx_disabling_bandwidth_bps_ = value;
}

// -------------------------------------------------------------------

// BitrateController

// optional int32 fl_increase_overhead_offset = 1;
inline bool BitrateController::has_fl_increase_overhead_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BitrateController::clear_fl_increase_overhead_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_increase_overhead_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t BitrateController::fl_increase_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.BitrateController.fl_increase_overhead_offset)
  return _internal_fl_increase_overhead_offset();
}
inline void BitrateController::set_fl_increase_overhead_offset(::int32_t value) {
  _internal_set_fl_increase_overhead_offset(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.BitrateController.fl_increase_overhead_offset)
}
inline ::int32_t BitrateController::_internal_fl_increase_overhead_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_increase_overhead_offset_;
}
inline void BitrateController::_internal_set_fl_increase_overhead_offset(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_increase_overhead_offset_ = value;
}

// optional int32 fl_decrease_overhead_offset = 2;
inline bool BitrateController::has_fl_decrease_overhead_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BitrateController::clear_fl_decrease_overhead_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_decrease_overhead_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BitrateController::fl_decrease_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.BitrateController.fl_decrease_overhead_offset)
  return _internal_fl_decrease_overhead_offset();
}
inline void BitrateController::set_fl_decrease_overhead_offset(::int32_t value) {
  _internal_set_fl_decrease_overhead_offset(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.BitrateController.fl_decrease_overhead_offset)
}
inline ::int32_t BitrateController::_internal_fl_decrease_overhead_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fl_decrease_overhead_offset_;
}
inline void BitrateController::_internal_set_fl_decrease_overhead_offset(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fl_decrease_overhead_offset_ = value;
}

// -------------------------------------------------------------------

// Controller_ScoringPoint

// optional int32 uplink_bandwidth_bps = 1;
inline bool Controller_ScoringPoint::has_uplink_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Controller_ScoringPoint::clear_uplink_bandwidth_bps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uplink_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Controller_ScoringPoint::uplink_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_bandwidth_bps)
  return _internal_uplink_bandwidth_bps();
}
inline void Controller_ScoringPoint::set_uplink_bandwidth_bps(::int32_t value) {
  _internal_set_uplink_bandwidth_bps(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_bandwidth_bps)
}
inline ::int32_t Controller_ScoringPoint::_internal_uplink_bandwidth_bps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uplink_bandwidth_bps_;
}
inline void Controller_ScoringPoint::_internal_set_uplink_bandwidth_bps(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uplink_bandwidth_bps_ = value;
}

// optional float uplink_packet_loss_fraction = 2;
inline bool Controller_ScoringPoint::has_uplink_packet_loss_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Controller_ScoringPoint::clear_uplink_packet_loss_fraction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uplink_packet_loss_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Controller_ScoringPoint::uplink_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_packet_loss_fraction)
  return _internal_uplink_packet_loss_fraction();
}
inline void Controller_ScoringPoint::set_uplink_packet_loss_fraction(float value) {
  _internal_set_uplink_packet_loss_fraction(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_packet_loss_fraction)
}
inline float Controller_ScoringPoint::_internal_uplink_packet_loss_fraction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uplink_packet_loss_fraction_;
}
inline void Controller_ScoringPoint::_internal_set_uplink_packet_loss_fraction(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uplink_packet_loss_fraction_ = value;
}

// -------------------------------------------------------------------

// Controller

// optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
inline bool Controller::has_scoring_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scoring_point_ != nullptr);
  return value;
}
inline void Controller::clear_scoring_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scoring_point_ != nullptr) _impl_.scoring_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& Controller::_internal_scoring_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* p = _impl_.scoring_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint&>(::webrtc::audio_network_adaptor::config::_Controller_ScoringPoint_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& Controller::scoring_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.scoring_point)
  return _internal_scoring_point();
}
inline void Controller::unsafe_arena_set_allocated_scoring_point(
    ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scoring_point_);
  }
  _impl_.scoring_point_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.scoring_point)
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NULLABLE Controller::release_scoring_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* released = _impl_.scoring_point_;
  _impl_.scoring_point_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NULLABLE Controller::unsafe_arena_release_scoring_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.scoring_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* temp = _impl_.scoring_point_;
  _impl_.scoring_point_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NONNULL Controller::_internal_mutable_scoring_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scoring_point_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint>(GetArena());
    _impl_.scoring_point_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(p);
  }
  return _impl_.scoring_point_;
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NONNULL Controller::mutable_scoring_point()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* _msg = _internal_mutable_scoring_point();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.scoring_point)
  return _msg;
}
inline void Controller::set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scoring_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.scoring_point_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.Controller.scoring_point)
}

// .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
inline bool Controller::has_fec_controller() const {
  return controller_case() == kFecController;
}
inline bool Controller::_internal_has_fec_controller() const {
  return controller_case() == kFecController;
}
inline void Controller::set_has_fec_controller() {
  _impl_._oneof_case_[0] = kFecController;
}
inline void Controller::clear_fec_controller() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (controller_case() == kFecController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.fec_controller_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.controller_.fec_controller_ != nullptr) {
        _impl_.controller_.fec_controller_->Clear();
      }
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NULLABLE Controller::release_fec_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  if (controller_case() == kFecController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController*>(_impl_.controller_.fec_controller_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.fec_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FecController& Controller::_internal_fec_controller() const {
  return controller_case() == kFecController ? *reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController*>(_impl_.controller_.fec_controller_) : reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController&>(::webrtc::audio_network_adaptor::config::_FecController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecController& Controller::fec_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  return _internal_fec_controller();
}
inline ::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NULLABLE Controller::unsafe_arena_release_fec_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  if (controller_case() == kFecController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController*>(_impl_.controller_.fec_controller_);
    _impl_.controller_.fec_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_fec_controller(
    ::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_fec_controller();
    _impl_.controller_.fec_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.fec_controller)
}
inline ::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NONNULL Controller::_internal_mutable_fec_controller() {
  if (controller_case() != kFecController) {
    clear_controller();
    set_has_fec_controller();
    _impl_.controller_.fec_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::FecController>(GetArena()));
  }
  return reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController*>(_impl_.controller_.fec_controller_);
}
inline ::webrtc::audio_network_adaptor::config::FecController* PROTOBUF_NONNULL Controller::mutable_fec_controller()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FecController* _msg = _internal_mutable_fec_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
inline bool Controller::has_frame_length_controller() const {
  return controller_case() == kFrameLengthController;
}
inline bool Controller::_internal_has_frame_length_controller() const {
  return controller_case() == kFrameLengthController;
}
inline void Controller::set_has_frame_length_controller() {
  _impl_._oneof_case_[0] = kFrameLengthController;
}
inline void Controller::clear_frame_length_controller() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (controller_case() == kFrameLengthController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.frame_length_controller_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.controller_.frame_length_controller_ != nullptr) {
        _impl_.controller_.frame_length_controller_->Clear();
      }
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NULLABLE Controller::release_frame_length_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  if (controller_case() == kFrameLengthController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthController*>(_impl_.controller_.frame_length_controller_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.frame_length_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FrameLengthController& Controller::_internal_frame_length_controller() const {
  return controller_case() == kFrameLengthController ? *reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthController*>(_impl_.controller_.frame_length_controller_) : reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthController&>(::webrtc::audio_network_adaptor::config::_FrameLengthController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FrameLengthController& Controller::frame_length_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  return _internal_frame_length_controller();
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NULLABLE Controller::unsafe_arena_release_frame_length_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  if (controller_case() == kFrameLengthController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthController*>(_impl_.controller_.frame_length_controller_);
    _impl_.controller_.frame_length_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_frame_length_controller(
    ::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_frame_length_controller();
    _impl_.controller_.frame_length_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NONNULL Controller::_internal_mutable_frame_length_controller() {
  if (controller_case() != kFrameLengthController) {
    clear_controller();
    set_has_frame_length_controller();
    _impl_.controller_.frame_length_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::FrameLengthController>(GetArena()));
  }
  return reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthController*>(_impl_.controller_.frame_length_controller_);
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* PROTOBUF_NONNULL Controller::mutable_frame_length_controller()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FrameLengthController* _msg = _internal_mutable_frame_length_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
inline bool Controller::has_channel_controller() const {
  return controller_case() == kChannelController;
}
inline bool Controller::_internal_has_channel_controller() const {
  return controller_case() == kChannelController;
}
inline void Controller::set_has_channel_controller() {
  _impl_._oneof_case_[0] = kChannelController;
}
inline void Controller::clear_channel_controller() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (controller_case() == kChannelController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.channel_controller_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.controller_.channel_controller_ != nullptr) {
        _impl_.controller_.channel_controller_->Clear();
      }
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NULLABLE Controller::release_channel_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  if (controller_case() == kChannelController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::ChannelController*>(_impl_.controller_.channel_controller_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.channel_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::ChannelController& Controller::_internal_channel_controller() const {
  return controller_case() == kChannelController ? *reinterpret_cast<::webrtc::audio_network_adaptor::config::ChannelController*>(_impl_.controller_.channel_controller_) : reinterpret_cast<::webrtc::audio_network_adaptor::config::ChannelController&>(::webrtc::audio_network_adaptor::config::_ChannelController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::ChannelController& Controller::channel_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  return _internal_channel_controller();
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NULLABLE Controller::unsafe_arena_release_channel_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  if (controller_case() == kChannelController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::ChannelController*>(_impl_.controller_.channel_controller_);
    _impl_.controller_.channel_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_channel_controller(
    ::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_channel_controller();
    _impl_.controller_.channel_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.channel_controller)
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NONNULL Controller::_internal_mutable_channel_controller() {
  if (controller_case() != kChannelController) {
    clear_controller();
    set_has_channel_controller();
    _impl_.controller_.channel_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::ChannelController>(GetArena()));
  }
  return reinterpret_cast<::webrtc::audio_network_adaptor::config::ChannelController*>(_impl_.controller_.channel_controller_);
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* PROTOBUF_NONNULL Controller::mutable_channel_controller()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::ChannelController* _msg = _internal_mutable_channel_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
inline bool Controller::has_dtx_controller() const {
  return controller_case() == kDtxController;
}
inline bool Controller::_internal_has_dtx_controller() const {
  return controller_case() == kDtxController;
}
inline void Controller::set_has_dtx_controller() {
  _impl_._oneof_case_[0] = kDtxController;
}
inline void Controller::clear_dtx_controller() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (controller_case() == kDtxController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.dtx_controller_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.controller_.dtx_controller_ != nullptr) {
        _impl_.controller_.dtx_controller_->Clear();
      }
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NULLABLE Controller::release_dtx_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  if (controller_case() == kDtxController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::DtxController*>(_impl_.controller_.dtx_controller_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.dtx_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::DtxController& Controller::_internal_dtx_controller() const {
  return controller_case() == kDtxController ? *reinterpret_cast<::webrtc::audio_network_adaptor::config::DtxController*>(_impl_.controller_.dtx_controller_) : reinterpret_cast<::webrtc::audio_network_adaptor::config::DtxController&>(::webrtc::audio_network_adaptor::config::_DtxController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::DtxController& Controller::dtx_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  return _internal_dtx_controller();
}
inline ::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NULLABLE Controller::unsafe_arena_release_dtx_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  if (controller_case() == kDtxController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::DtxController*>(_impl_.controller_.dtx_controller_);
    _impl_.controller_.dtx_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_dtx_controller(
    ::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_dtx_controller();
    _impl_.controller_.dtx_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
}
inline ::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NONNULL Controller::_internal_mutable_dtx_controller() {
  if (controller_case() != kDtxController) {
    clear_controller();
    set_has_dtx_controller();
    _impl_.controller_.dtx_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::DtxController>(GetArena()));
  }
  return reinterpret_cast<::webrtc::audio_network_adaptor::config::DtxController*>(_impl_.controller_.dtx_controller_);
}
inline ::webrtc::audio_network_adaptor::config::DtxController* PROTOBUF_NONNULL Controller::mutable_dtx_controller()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::DtxController* _msg = _internal_mutable_dtx_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
inline bool Controller::has_bitrate_controller() const {
  return controller_case() == kBitrateController;
}
inline bool Controller::_internal_has_bitrate_controller() const {
  return controller_case() == kBitrateController;
}
inline void Controller::set_has_bitrate_controller() {
  _impl_._oneof_case_[0] = kBitrateController;
}
inline void Controller::clear_bitrate_controller() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (controller_case() == kBitrateController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.bitrate_controller_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.controller_.bitrate_controller_ != nullptr) {
        _impl_.controller_.bitrate_controller_->Clear();
      }
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NULLABLE Controller::release_bitrate_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  if (controller_case() == kBitrateController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::BitrateController*>(_impl_.controller_.bitrate_controller_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.bitrate_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::BitrateController& Controller::_internal_bitrate_controller() const {
  return controller_case() == kBitrateController ? *reinterpret_cast<::webrtc::audio_network_adaptor::config::BitrateController*>(_impl_.controller_.bitrate_controller_) : reinterpret_cast<::webrtc::audio_network_adaptor::config::BitrateController&>(::webrtc::audio_network_adaptor::config::_BitrateController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::BitrateController& Controller::bitrate_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  return _internal_bitrate_controller();
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NULLABLE Controller::unsafe_arena_release_bitrate_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  if (controller_case() == kBitrateController) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::BitrateController*>(_impl_.controller_.bitrate_controller_);
    _impl_.controller_.bitrate_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_bitrate_controller(
    ::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_bitrate_controller();
    _impl_.controller_.bitrate_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NONNULL Controller::_internal_mutable_bitrate_controller() {
  if (controller_case() != kBitrateController) {
    clear_controller();
    set_has_bitrate_controller();
    _impl_.controller_.bitrate_controller_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::BitrateController>(GetArena()));
  }
  return reinterpret_cast<::webrtc::audio_network_adaptor::config::BitrateController*>(_impl_.controller_.bitrate_controller_);
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* PROTOBUF_NONNULL Controller::mutable_bitrate_controller()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::BitrateController* _msg = _internal_mutable_bitrate_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.FecControllerRplrBased fec_controller_rplr_based = 26;
inline bool Controller::has_fec_controller_rplr_based() const {
  return controller_case() == kFecControllerRplrBased;
}
inline bool Controller::_internal_has_fec_controller_rplr_based() const {
  return controller_case() == kFecControllerRplrBased;
}
inline void Controller::set_has_fec_controller_rplr_based() {
  _impl_._oneof_case_[0] = kFecControllerRplrBased;
}
inline void Controller::clear_fec_controller_rplr_based() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (controller_case() == kFecControllerRplrBased) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.fec_controller_rplr_based_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.controller_.fec_controller_rplr_based_ != nullptr) {
        _impl_.controller_.fec_controller_rplr_based_->Clear();
      }
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NULLABLE Controller::release_fec_controller_rplr_based() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  if (controller_case() == kFecControllerRplrBased) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased*>(_impl_.controller_.fec_controller_rplr_based_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.fec_controller_rplr_based_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& Controller::_internal_fec_controller_rplr_based() const {
  return controller_case() == kFecControllerRplrBased ? *reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased*>(_impl_.controller_.fec_controller_rplr_based_) : reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased&>(::webrtc::audio_network_adaptor::config::_FecControllerRplrBased_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& Controller::fec_controller_rplr_based() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  return _internal_fec_controller_rplr_based();
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NULLABLE Controller::unsafe_arena_release_fec_controller_rplr_based() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  if (controller_case() == kFecControllerRplrBased) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased*>(_impl_.controller_.fec_controller_rplr_based_);
    _impl_.controller_.fec_controller_rplr_based_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_fec_controller_rplr_based(
    ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_fec_controller_rplr_based();
    _impl_.controller_.fec_controller_rplr_based_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NONNULL Controller::_internal_mutable_fec_controller_rplr_based() {
  if (controller_case() != kFecControllerRplrBased) {
    clear_controller();
    set_has_fec_controller_rplr_based();
    _impl_.controller_.fec_controller_rplr_based_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::FecControllerRplrBased>(GetArena()));
  }
  return reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased*>(_impl_.controller_.fec_controller_rplr_based_);
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* PROTOBUF_NONNULL Controller::mutable_fec_controller_rplr_based()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* _msg = _internal_mutable_fec_controller_rplr_based();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.FrameLengthControllerV2 frame_length_controller_v2 = 27;
inline bool Controller::has_frame_length_controller_v2() const {
  return controller_case() == kFrameLengthControllerV2;
}
inline bool Controller::_internal_has_frame_length_controller_v2() const {
  return controller_case() == kFrameLengthControllerV2;
}
inline void Controller::set_has_frame_length_controller_v2() {
  _impl_._oneof_case_[0] = kFrameLengthControllerV2;
}
inline void Controller::clear_frame_length_controller_v2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (controller_case() == kFrameLengthControllerV2) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.frame_length_controller_v2_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.controller_.frame_length_controller_v2_ != nullptr) {
        _impl_.controller_.frame_length_controller_v2_->Clear();
      }
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NULLABLE Controller::release_frame_length_controller_v2() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
  if (controller_case() == kFrameLengthControllerV2) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthControllerV2*>(_impl_.controller_.frame_length_controller_v2_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.frame_length_controller_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2& Controller::_internal_frame_length_controller_v2() const {
  return controller_case() == kFrameLengthControllerV2 ? *reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthControllerV2*>(_impl_.controller_.frame_length_controller_v2_) : reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthControllerV2&>(::webrtc::audio_network_adaptor::config::_FrameLengthControllerV2_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2& Controller::frame_length_controller_v2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
  return _internal_frame_length_controller_v2();
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NULLABLE Controller::unsafe_arena_release_frame_length_controller_v2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
  if (controller_case() == kFrameLengthControllerV2) {
    clear_has_controller();
    auto* temp = reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthControllerV2*>(_impl_.controller_.frame_length_controller_v2_);
    _impl_.controller_.frame_length_controller_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_frame_length_controller_v2(
    ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_frame_length_controller_v2();
    _impl_.controller_.frame_length_controller_v2_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NONNULL Controller::_internal_mutable_frame_length_controller_v2() {
  if (controller_case() != kFrameLengthControllerV2) {
    clear_controller();
    set_has_frame_length_controller_v2();
    _impl_.controller_.frame_length_controller_v2_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::webrtc::audio_network_adaptor::config::FrameLengthControllerV2>(GetArena()));
  }
  return reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthControllerV2*>(_impl_.controller_.frame_length_controller_v2_);
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* PROTOBUF_NONNULL Controller::mutable_frame_length_controller_v2()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* _msg = _internal_mutable_frame_length_controller_v2();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
  return _msg;
}

inline bool Controller::has_controller() const {
  return controller_case() != CONTROLLER_NOT_SET;
}
inline void Controller::clear_has_controller() {
  _impl_._oneof_case_[0] = CONTROLLER_NOT_SET;
}
inline Controller::ControllerCase Controller::controller_case() const {
  return Controller::ControllerCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControllerManager

// repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
inline int ControllerManager::_internal_controllers_size() const {
  return _internal_controllers().size();
}
inline int ControllerManager::controllers_size() const {
  return _internal_controllers_size();
}
inline void ControllerManager::clear_controllers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.controllers_.Clear();
}
inline ::webrtc::audio_network_adaptor::config::Controller* PROTOBUF_NONNULL ControllerManager::mutable_controllers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return _internal_mutable_controllers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>* PROTOBUF_NONNULL ControllerManager::mutable_controllers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_controllers();
}
inline const ::webrtc::audio_network_adaptor::config::Controller& ControllerManager::controllers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return _internal_controllers().Get(index);
}
inline ::webrtc::audio_network_adaptor::config::Controller* PROTOBUF_NONNULL ControllerManager::add_controllers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::webrtc::audio_network_adaptor::config::Controller* _add = _internal_mutable_controllers()->Add();
  // @@protoc_insertion_point(field_add:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>& ControllerManager::controllers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return _internal_controllers();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>&
ControllerManager::_internal_controllers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.controllers_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>* PROTOBUF_NONNULL
ControllerManager::_internal_mutable_controllers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.controllers_;
}

// optional int32 min_reordering_time_ms = 2;
inline bool ControllerManager::has_min_reordering_time_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ControllerManager::clear_min_reordering_time_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_reordering_time_ms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ControllerManager::min_reordering_time_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_time_ms)
  return _internal_min_reordering_time_ms();
}
inline void ControllerManager::set_min_reordering_time_ms(::int32_t value) {
  _internal_set_min_reordering_time_ms(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_time_ms)
}
inline ::int32_t ControllerManager::_internal_min_reordering_time_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_reordering_time_ms_;
}
inline void ControllerManager::_internal_set_min_reordering_time_ms(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_reordering_time_ms_ = value;
}

// optional float min_reordering_squared_distance = 3;
inline bool ControllerManager::has_min_reordering_squared_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ControllerManager::clear_min_reordering_squared_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_reordering_squared_distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ControllerManager::min_reordering_squared_distance() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_squared_distance)
  return _internal_min_reordering_squared_distance();
}
inline void ControllerManager::set_min_reordering_squared_distance(float value) {
  _internal_set_min_reordering_squared_distance(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_squared_distance)
}
inline float ControllerManager::_internal_min_reordering_squared_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_reordering_squared_distance_;
}
inline void ControllerManager::_internal_set_min_reordering_squared_distance(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_reordering_squared_distance_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace config
}  // namespace audio_network_adaptor
}  // namespace webrtc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // config_2eproto_2epb_2eh
