// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_HISTOGRAM_SAMPLES_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_HISTOGRAM_SAMPLES_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class ChromiumHistogramSamplesConfig;
class ChromiumHistogramSamplesConfig_HistogramSample;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT ChromiumHistogramSamplesConfig : public ::protozero::CppMessageObj {
 public:
  using HistogramSample = ChromiumHistogramSamplesConfig_HistogramSample;
  enum FieldNumbers {
    kHistogramsFieldNumber = 1,
    kFilterHistogramNamesFieldNumber = 2,
  };

  ChromiumHistogramSamplesConfig();
  ~ChromiumHistogramSamplesConfig() override;
  ChromiumHistogramSamplesConfig(ChromiumHistogramSamplesConfig&&) noexcept;
  ChromiumHistogramSamplesConfig& operator=(ChromiumHistogramSamplesConfig&&);
  ChromiumHistogramSamplesConfig(const ChromiumHistogramSamplesConfig&);
  ChromiumHistogramSamplesConfig& operator=(const ChromiumHistogramSamplesConfig&);
  bool operator==(const ChromiumHistogramSamplesConfig&) const;
  bool operator!=(const ChromiumHistogramSamplesConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<ChromiumHistogramSamplesConfig_HistogramSample>& histograms() const { return histograms_; }
  std::vector<ChromiumHistogramSamplesConfig_HistogramSample>* mutable_histograms() { return &histograms_; }
  int histograms_size() const;
  void clear_histograms();
  ChromiumHistogramSamplesConfig_HistogramSample* add_histograms();

  bool has_filter_histogram_names() const { return _has_field_[2]; }
  bool filter_histogram_names() const { return filter_histogram_names_; }
  void set_filter_histogram_names(bool value) { filter_histogram_names_ = value; _has_field_.set(2); }

 private:
  std::vector<ChromiumHistogramSamplesConfig_HistogramSample> histograms_;
  bool filter_histogram_names_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ChromiumHistogramSamplesConfig_HistogramSample : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kHistogramNameFieldNumber = 1,
    kMinValueFieldNumber = 2,
    kMaxValueFieldNumber = 3,
  };

  ChromiumHistogramSamplesConfig_HistogramSample();
  ~ChromiumHistogramSamplesConfig_HistogramSample() override;
  ChromiumHistogramSamplesConfig_HistogramSample(ChromiumHistogramSamplesConfig_HistogramSample&&) noexcept;
  ChromiumHistogramSamplesConfig_HistogramSample& operator=(ChromiumHistogramSamplesConfig_HistogramSample&&);
  ChromiumHistogramSamplesConfig_HistogramSample(const ChromiumHistogramSamplesConfig_HistogramSample&);
  ChromiumHistogramSamplesConfig_HistogramSample& operator=(const ChromiumHistogramSamplesConfig_HistogramSample&);
  bool operator==(const ChromiumHistogramSamplesConfig_HistogramSample&) const;
  bool operator!=(const ChromiumHistogramSamplesConfig_HistogramSample& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_histogram_name() const { return _has_field_[1]; }
  const std::string& histogram_name() const { return histogram_name_; }
  void set_histogram_name(const std::string& value) { histogram_name_ = value; _has_field_.set(1); }

  bool has_min_value() const { return _has_field_[2]; }
  int64_t min_value() const { return min_value_; }
  void set_min_value(int64_t value) { min_value_ = value; _has_field_.set(2); }

  bool has_max_value() const { return _has_field_[3]; }
  int64_t max_value() const { return max_value_; }
  void set_max_value(int64_t value) { max_value_ = value; _has_field_.set(3); }

 private:
  std::string histogram_name_{};
  int64_t min_value_{};
  int64_t max_value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_HISTOGRAM_SAMPLES_PROTO_CPP_H_
