// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: histogram.proto
// Protobuf C++ Version: 6.30.1

#ifndef histogram_2eproto_2epb_2eh
#define histogram_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6030001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_field_lite.h"
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_histogram_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_histogram_2eproto {
  static const ::uint32_t offsets[];
};
namespace catapult {
namespace tracing {
namespace tracing {
namespace proto {
enum BinBoundaryDetailedSpec_Type : int;
extern const uint32_t BinBoundaryDetailedSpec_Type_internal_data_[];
enum ImprovementDirection : int;
extern const uint32_t ImprovementDirection_internal_data_[];
enum Unit : int;
extern const uint32_t Unit_internal_data_[];
class Bin;
struct BinDefaultTypeInternal;
extern BinDefaultTypeInternal _Bin_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<35> Bin_class_data_;
class BinBoundaries;
struct BinBoundariesDefaultTypeInternal;
extern BinBoundariesDefaultTypeInternal _BinBoundaries_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<45> BinBoundaries_class_data_;
class BinBoundaryDetailedSpec;
struct BinBoundaryDetailedSpecDefaultTypeInternal;
extern BinBoundaryDetailedSpecDefaultTypeInternal _BinBoundaryDetailedSpec_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<55> BinBoundaryDetailedSpec_class_data_;
class BinBoundarySpec;
struct BinBoundarySpecDefaultTypeInternal;
extern BinBoundarySpecDefaultTypeInternal _BinBoundarySpec_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<47> BinBoundarySpec_class_data_;
class Breakdown;
struct BreakdownDefaultTypeInternal;
extern BreakdownDefaultTypeInternal _Breakdown_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<41> Breakdown_class_data_;
class DateRange;
struct DateRangeDefaultTypeInternal;
extern DateRangeDefaultTypeInternal _DateRange_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<41> DateRange_class_data_;
class Diagnostic;
struct DiagnosticDefaultTypeInternal;
extern DiagnosticDefaultTypeInternal _Diagnostic_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<42> Diagnostic_class_data_;
class DiagnosticMap;
struct DiagnosticMapDefaultTypeInternal;
extern DiagnosticMapDefaultTypeInternal _DiagnosticMap_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<45> DiagnosticMap_class_data_;
class GenericSet;
struct GenericSetDefaultTypeInternal;
extern GenericSetDefaultTypeInternal _GenericSet_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<42> GenericSet_class_data_;
class Histogram;
struct HistogramDefaultTypeInternal;
extern HistogramDefaultTypeInternal _Histogram_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<41> Histogram_class_data_;
class HistogramSet;
struct HistogramSetDefaultTypeInternal;
extern HistogramSetDefaultTypeInternal _HistogramSet_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<44> HistogramSet_class_data_;
class RelatedEventSet;
struct RelatedEventSetDefaultTypeInternal;
extern RelatedEventSetDefaultTypeInternal _RelatedEventSet_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<47> RelatedEventSet_class_data_;
class RelatedNameMap;
struct RelatedNameMapDefaultTypeInternal;
extern RelatedNameMapDefaultTypeInternal _RelatedNameMap_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<46> RelatedNameMap_class_data_;
class RunningStatistics;
struct RunningStatisticsDefaultTypeInternal;
extern RunningStatisticsDefaultTypeInternal _RunningStatistics_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<49> RunningStatistics_class_data_;
class Scalar;
struct ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<38> Scalar_class_data_;
class SummaryOptions;
struct SummaryOptionsDefaultTypeInternal;
extern SummaryOptionsDefaultTypeInternal _SummaryOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<46> SummaryOptions_class_data_;
class UnitAndDirection;
struct UnitAndDirectionDefaultTypeInternal;
extern UnitAndDirectionDefaultTypeInternal _UnitAndDirection_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<48> UnitAndDirection_class_data_;
}  // namespace proto
}  // namespace tracing
}  // namespace tracing
}  // namespace catapult
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type_internal_data_>
    internal::EnumTraitsImpl::value<::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type>;
template <>
internal::EnumTraitsT<::catapult::tracing::tracing::proto::ImprovementDirection_internal_data_>
    internal::EnumTraitsImpl::value<::catapult::tracing::tracing::proto::ImprovementDirection>;
template <>
internal::EnumTraitsT<::catapult::tracing::tracing::proto::Unit_internal_data_>
    internal::EnumTraitsImpl::value<::catapult::tracing::tracing::proto::Unit>;
}  // namespace protobuf
}  // namespace google

namespace catapult {
namespace tracing {
namespace tracing {
namespace proto {
enum BinBoundaryDetailedSpec_Type : int {
  BinBoundaryDetailedSpec_Type_LINEAR = 0,
  BinBoundaryDetailedSpec_Type_EXPONENTIAL = 1,
  BinBoundaryDetailedSpec_Type_BinBoundaryDetailedSpec_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BinBoundaryDetailedSpec_Type_BinBoundaryDetailedSpec_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BinBoundaryDetailedSpec_Type_internal_data_[];
inline constexpr BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec_Type_Type_MIN =
    static_cast<BinBoundaryDetailedSpec_Type>(0);
inline constexpr BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec_Type_Type_MAX =
    static_cast<BinBoundaryDetailedSpec_Type>(1);
inline bool BinBoundaryDetailedSpec_Type_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int BinBoundaryDetailedSpec_Type_Type_ARRAYSIZE = 1 + 1;
const std::string& BinBoundaryDetailedSpec_Type_Name(BinBoundaryDetailedSpec_Type value);
template <typename T>
const std::string& BinBoundaryDetailedSpec_Type_Name(T value) {
  static_assert(std::is_same<T, BinBoundaryDetailedSpec_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return BinBoundaryDetailedSpec_Type_Name(static_cast<BinBoundaryDetailedSpec_Type>(value));
}
bool BinBoundaryDetailedSpec_Type_Parse(
    absl::string_view name, BinBoundaryDetailedSpec_Type* PROTOBUF_NONNULL value);
enum ImprovementDirection : int {
  NOT_SPECIFIED = 0,
  BIGGER_IS_BETTER = 1,
  SMALLER_IS_BETTER = 2,
  ImprovementDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ImprovementDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ImprovementDirection_internal_data_[];
inline constexpr ImprovementDirection ImprovementDirection_MIN =
    static_cast<ImprovementDirection>(0);
inline constexpr ImprovementDirection ImprovementDirection_MAX =
    static_cast<ImprovementDirection>(2);
inline bool ImprovementDirection_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ImprovementDirection_ARRAYSIZE = 2 + 1;
const std::string& ImprovementDirection_Name(ImprovementDirection value);
template <typename T>
const std::string& ImprovementDirection_Name(T value) {
  static_assert(std::is_same<T, ImprovementDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ImprovementDirection_Name().");
  return ImprovementDirection_Name(static_cast<ImprovementDirection>(value));
}
bool ImprovementDirection_Parse(
    absl::string_view name, ImprovementDirection* PROTOBUF_NONNULL value);
enum Unit : int {
  MS = 0,
  MS_BEST_FIT_FORMAT = 1,
  TS_MS = 2,
  N_PERCENT = 3,
  SIZE_IN_BYTES = 4,
  BYTES_PER_SECOND = 5,
  J = 6,
  W = 7,
  A = 8,
  V = 9,
  HERTZ = 10,
  UNITLESS = 11,
  COUNT = 12,
  SIGMA = 13,
  AH = 14,
  Unit_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Unit_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Unit_internal_data_[];
inline constexpr Unit Unit_MIN =
    static_cast<Unit>(0);
inline constexpr Unit Unit_MAX =
    static_cast<Unit>(14);
inline bool Unit_IsValid(int value) {
  return 0 <= value && value <= 14;
}
inline constexpr int Unit_ARRAYSIZE = 14 + 1;
const std::string& Unit_Name(Unit value);
template <typename T>
const std::string& Unit_Name(T value) {
  static_assert(std::is_same<T, Unit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Unit_Name().");
  return Unit_Name(static_cast<Unit>(value));
}
bool Unit_Parse(
    absl::string_view name, Unit* PROTOBUF_NONNULL value);

// ===================================================================


// -------------------------------------------------------------------

class UnitAndDirection final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.UnitAndDirection) */ {
 public:
  inline UnitAndDirection() : UnitAndDirection(nullptr) {}
  ~UnitAndDirection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UnitAndDirection* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UnitAndDirection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnitAndDirection(::google::protobuf::internal::ConstantInitialized);

  inline UnitAndDirection(const UnitAndDirection& from) : UnitAndDirection(nullptr, from) {}
  inline UnitAndDirection(UnitAndDirection&& from) noexcept
      : UnitAndDirection(nullptr, std::move(from)) {}
  inline UnitAndDirection& operator=(const UnitAndDirection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitAndDirection& operator=(UnitAndDirection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UnitAndDirection& default_instance() {
    return *reinterpret_cast<const UnitAndDirection*>(
        &_UnitAndDirection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(UnitAndDirection& a, UnitAndDirection& b) { a.Swap(&b); }
  inline void Swap(UnitAndDirection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitAndDirection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnitAndDirection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<UnitAndDirection>(arena);
  }
  void CopyFrom(const UnitAndDirection& from);
  void MergeFrom(const UnitAndDirection& from) { UnitAndDirection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UnitAndDirection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.UnitAndDirection"; }

 protected:
  explicit UnitAndDirection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UnitAndDirection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UnitAndDirection& from);
  UnitAndDirection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UnitAndDirection&& from) noexcept
      : UnitAndDirection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUnitFieldNumber = 1,
    kImprovementDirectionFieldNumber = 2,
  };
  // .catapult.tracing.tracing.proto.Unit unit = 1;
  void clear_unit() ;
  ::catapult::tracing::tracing::proto::Unit unit() const;
  void set_unit(::catapult::tracing::tracing::proto::Unit value);

  private:
  ::catapult::tracing::tracing::proto::Unit _internal_unit() const;
  void _internal_set_unit(::catapult::tracing::tracing::proto::Unit value);

  public:
  // .catapult.tracing.tracing.proto.ImprovementDirection improvement_direction = 2;
  void clear_improvement_direction() ;
  ::catapult::tracing::tracing::proto::ImprovementDirection improvement_direction() const;
  void set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value);

  private:
  ::catapult::tracing::tracing::proto::ImprovementDirection _internal_improvement_direction() const;
  void _internal_set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value);

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.UnitAndDirection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UnitAndDirection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int unit_;
    int improvement_direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<48> UnitAndDirection_class_data_;
// -------------------------------------------------------------------

class SummaryOptions final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.SummaryOptions) */ {
 public:
  inline SummaryOptions() : SummaryOptions(nullptr) {}
  ~SummaryOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SummaryOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SummaryOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SummaryOptions(::google::protobuf::internal::ConstantInitialized);

  inline SummaryOptions(const SummaryOptions& from) : SummaryOptions(nullptr, from) {}
  inline SummaryOptions(SummaryOptions&& from) noexcept
      : SummaryOptions(nullptr, std::move(from)) {}
  inline SummaryOptions& operator=(const SummaryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SummaryOptions& operator=(SummaryOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SummaryOptions& default_instance() {
    return *reinterpret_cast<const SummaryOptions*>(
        &_SummaryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SummaryOptions& a, SummaryOptions& b) { a.Swap(&b); }
  inline void Swap(SummaryOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SummaryOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SummaryOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<SummaryOptions>(arena);
  }
  void CopyFrom(const SummaryOptions& from);
  void MergeFrom(const SummaryOptions& from) { SummaryOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SummaryOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.SummaryOptions"; }

 protected:
  explicit SummaryOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SummaryOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SummaryOptions& from);
  SummaryOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SummaryOptions&& from) noexcept
      : SummaryOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPercentileFieldNumber = 9,
    kAvgFieldNumber = 1,
    kGeometricMeanFieldNumber = 2,
    kStdFieldNumber = 3,
    kCountFieldNumber = 4,
    kSumFieldNumber = 5,
    kMinFieldNumber = 6,
    kMaxFieldNumber = 7,
    kNansFieldNumber = 8,
  };
  // repeated float percentile = 9;
  int percentile_size() const;
  private:
  int _internal_percentile_size() const;

  public:
  void clear_percentile() ;
  float percentile(int index) const;
  void set_percentile(int index, float value);
  void add_percentile(float value);
  const ::google::protobuf::RepeatedField<float>& percentile() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_percentile();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_percentile() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_percentile();

  public:
  // bool avg = 1;
  void clear_avg() ;
  bool avg() const;
  void set_avg(bool value);

  private:
  bool _internal_avg() const;
  void _internal_set_avg(bool value);

  public:
  // bool geometric_mean = 2;
  void clear_geometric_mean() ;
  bool geometric_mean() const;
  void set_geometric_mean(bool value);

  private:
  bool _internal_geometric_mean() const;
  void _internal_set_geometric_mean(bool value);

  public:
  // bool std = 3;
  void clear_std() ;
  bool std() const;
  void set_std(bool value);

  private:
  bool _internal_std() const;
  void _internal_set_std(bool value);

  public:
  // bool count = 4;
  void clear_count() ;
  bool count() const;
  void set_count(bool value);

  private:
  bool _internal_count() const;
  void _internal_set_count(bool value);

  public:
  // bool sum = 5;
  void clear_sum() ;
  bool sum() const;
  void set_sum(bool value);

  private:
  bool _internal_sum() const;
  void _internal_set_sum(bool value);

  public:
  // bool min = 6;
  void clear_min() ;
  bool min() const;
  void set_min(bool value);

  private:
  bool _internal_min() const;
  void _internal_set_min(bool value);

  public:
  // bool max = 7;
  void clear_max() ;
  bool max() const;
  void set_max(bool value);

  private:
  bool _internal_max() const;
  void _internal_set_max(bool value);

  public:
  // bool nans = 8;
  void clear_nans() ;
  bool nans() const;
  void set_nans(bool value);

  private:
  bool _internal_nans() const;
  void _internal_set_nans(bool value);

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.SummaryOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SummaryOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> percentile_;
    bool avg_;
    bool geometric_mean_;
    bool std_;
    bool count_;
    bool sum_;
    bool min_;
    bool max_;
    bool nans_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<46> SummaryOptions_class_data_;
// -------------------------------------------------------------------

class Scalar final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Scalar) */ {
 public:
  inline Scalar() : Scalar(nullptr) {}
  ~Scalar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Scalar* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Scalar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Scalar(::google::protobuf::internal::ConstantInitialized);

  inline Scalar(const Scalar& from) : Scalar(nullptr, from) {}
  inline Scalar(Scalar&& from) noexcept
      : Scalar(nullptr, std::move(from)) {}
  inline Scalar& operator=(const Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scalar& operator=(Scalar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Scalar& default_instance() {
    return *reinterpret_cast<const Scalar*>(
        &_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Scalar& a, Scalar& b) { a.Swap(&b); }
  inline void Swap(Scalar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scalar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Scalar* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Scalar>(arena);
  }
  void CopyFrom(const Scalar& from);
  void MergeFrom(const Scalar& from) { Scalar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Scalar* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.Scalar"; }

 protected:
  explicit Scalar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Scalar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Scalar& from);
  Scalar(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Scalar&& from) noexcept
      : Scalar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Scalar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Scalar& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<38> Scalar_class_data_;
// -------------------------------------------------------------------

class RunningStatistics final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.RunningStatistics) */ {
 public:
  inline RunningStatistics() : RunningStatistics(nullptr) {}
  ~RunningStatistics() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RunningStatistics* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RunningStatistics));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunningStatistics(::google::protobuf::internal::ConstantInitialized);

  inline RunningStatistics(const RunningStatistics& from) : RunningStatistics(nullptr, from) {}
  inline RunningStatistics(RunningStatistics&& from) noexcept
      : RunningStatistics(nullptr, std::move(from)) {}
  inline RunningStatistics& operator=(const RunningStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunningStatistics& operator=(RunningStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RunningStatistics& default_instance() {
    return *reinterpret_cast<const RunningStatistics*>(
        &_RunningStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RunningStatistics& a, RunningStatistics& b) { a.Swap(&b); }
  inline void Swap(RunningStatistics* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunningStatistics* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunningStatistics* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<RunningStatistics>(arena);
  }
  void CopyFrom(const RunningStatistics& from);
  void MergeFrom(const RunningStatistics& from) { RunningStatistics::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RunningStatistics* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.RunningStatistics"; }

 protected:
  explicit RunningStatistics(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RunningStatistics(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RunningStatistics& from);
  RunningStatistics(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RunningStatistics&& from) noexcept
      : RunningStatistics(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxFieldNumber = 2,
    kMeanlogsFieldNumber = 3,
    kMeanFieldNumber = 4,
    kMinFieldNumber = 5,
    kSumFieldNumber = 6,
    kVarianceFieldNumber = 7,
    kCountFieldNumber = 1,
  };
  // double max = 2;
  void clear_max() ;
  double max() const;
  void set_max(double value);

  private:
  double _internal_max() const;
  void _internal_set_max(double value);

  public:
  // double meanlogs = 3;
  void clear_meanlogs() ;
  double meanlogs() const;
  void set_meanlogs(double value);

  private:
  double _internal_meanlogs() const;
  void _internal_set_meanlogs(double value);

  public:
  // double mean = 4;
  void clear_mean() ;
  double mean() const;
  void set_mean(double value);

  private:
  double _internal_mean() const;
  void _internal_set_mean(double value);

  public:
  // double min = 5;
  void clear_min() ;
  double min() const;
  void set_min(double value);

  private:
  double _internal_min() const;
  void _internal_set_min(double value);

  public:
  // double sum = 6;
  void clear_sum() ;
  double sum() const;
  void set_sum(double value);

  private:
  double _internal_sum() const;
  void _internal_set_sum(double value);

  public:
  // double variance = 7;
  void clear_variance() ;
  double variance() const;
  void set_variance(double value);

  private:
  double _internal_variance() const;
  void _internal_set_variance(double value);

  public:
  // int32 count = 1;
  void clear_count() ;
  ::int32_t count() const;
  void set_count(::int32_t value);

  private:
  ::int32_t _internal_count() const;
  void _internal_set_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.RunningStatistics)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RunningStatistics& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double max_;
    double meanlogs_;
    double mean_;
    double min_;
    double sum_;
    double variance_;
    ::int32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<49> RunningStatistics_class_data_;
// -------------------------------------------------------------------

class RelatedNameMap final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.RelatedNameMap) */ {
 public:
  inline RelatedNameMap() : RelatedNameMap(nullptr) {}
  ~RelatedNameMap() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RelatedNameMap* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RelatedNameMap));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelatedNameMap(::google::protobuf::internal::ConstantInitialized);

  inline RelatedNameMap(const RelatedNameMap& from) : RelatedNameMap(nullptr, from) {}
  inline RelatedNameMap(RelatedNameMap&& from) noexcept
      : RelatedNameMap(nullptr, std::move(from)) {}
  inline RelatedNameMap& operator=(const RelatedNameMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelatedNameMap& operator=(RelatedNameMap&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RelatedNameMap& default_instance() {
    return *reinterpret_cast<const RelatedNameMap*>(
        &_RelatedNameMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RelatedNameMap& a, RelatedNameMap& b) { a.Swap(&b); }
  inline void Swap(RelatedNameMap* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelatedNameMap* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelatedNameMap* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<RelatedNameMap>(arena);
  }
  void CopyFrom(const RelatedNameMap& from);
  void MergeFrom(const RelatedNameMap& from) { RelatedNameMap::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RelatedNameMap* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.RelatedNameMap"; }

 protected:
  explicit RelatedNameMap(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RelatedNameMap(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RelatedNameMap& from);
  RelatedNameMap(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RelatedNameMap&& from) noexcept
      : RelatedNameMap(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.RelatedNameMap)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RelatedNameMap& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<46> RelatedNameMap_class_data_;
// -------------------------------------------------------------------

class RelatedEventSet final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.RelatedEventSet) */ {
 public:
  inline RelatedEventSet() : RelatedEventSet(nullptr) {}
  ~RelatedEventSet() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RelatedEventSet* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RelatedEventSet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelatedEventSet(::google::protobuf::internal::ConstantInitialized);

  inline RelatedEventSet(const RelatedEventSet& from) : RelatedEventSet(nullptr, from) {}
  inline RelatedEventSet(RelatedEventSet&& from) noexcept
      : RelatedEventSet(nullptr, std::move(from)) {}
  inline RelatedEventSet& operator=(const RelatedEventSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelatedEventSet& operator=(RelatedEventSet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RelatedEventSet& default_instance() {
    return *reinterpret_cast<const RelatedEventSet*>(
        &_RelatedEventSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(RelatedEventSet& a, RelatedEventSet& b) { a.Swap(&b); }
  inline void Swap(RelatedEventSet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelatedEventSet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelatedEventSet* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<RelatedEventSet>(arena);
  }
  void CopyFrom(const RelatedEventSet& from);
  void MergeFrom(const RelatedEventSet& from) { RelatedEventSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RelatedEventSet* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.RelatedEventSet"; }

 protected:
  explicit RelatedEventSet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RelatedEventSet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RelatedEventSet& from);
  RelatedEventSet(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RelatedEventSet&& from) noexcept
      : RelatedEventSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.RelatedEventSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RelatedEventSet& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<47> RelatedEventSet_class_data_;
// -------------------------------------------------------------------

class GenericSet final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.GenericSet) */ {
 public:
  inline GenericSet() : GenericSet(nullptr) {}
  ~GenericSet() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GenericSet* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GenericSet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenericSet(::google::protobuf::internal::ConstantInitialized);

  inline GenericSet(const GenericSet& from) : GenericSet(nullptr, from) {}
  inline GenericSet(GenericSet&& from) noexcept
      : GenericSet(nullptr, std::move(from)) {}
  inline GenericSet& operator=(const GenericSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericSet& operator=(GenericSet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GenericSet& default_instance() {
    return *reinterpret_cast<const GenericSet*>(
        &_GenericSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(GenericSet& a, GenericSet& b) { a.Swap(&b); }
  inline void Swap(GenericSet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericSet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericSet* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<GenericSet>(arena);
  }
  void CopyFrom(const GenericSet& from);
  void MergeFrom(const GenericSet& from) { GenericSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GenericSet* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.GenericSet"; }

 protected:
  explicit GenericSet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GenericSet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GenericSet& from);
  GenericSet(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GenericSet&& from) noexcept
      : GenericSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  const std::string& values(int index) const;
  std::string* PROTOBUF_NONNULL mutable_values(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_values(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_values();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_values(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.GenericSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GenericSet& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> values_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<42> GenericSet_class_data_;
// -------------------------------------------------------------------

class DateRange final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.DateRange) */ {
 public:
  inline DateRange() : DateRange(nullptr) {}
  ~DateRange() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DateRange* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DateRange));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DateRange(::google::protobuf::internal::ConstantInitialized);

  inline DateRange(const DateRange& from) : DateRange(nullptr, from) {}
  inline DateRange(DateRange&& from) noexcept
      : DateRange(nullptr, std::move(from)) {}
  inline DateRange& operator=(const DateRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateRange& operator=(DateRange&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DateRange& default_instance() {
    return *reinterpret_cast<const DateRange*>(
        &_DateRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(DateRange& a, DateRange& b) { a.Swap(&b); }
  inline void Swap(DateRange* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateRange* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateRange* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<DateRange>(arena);
  }
  void CopyFrom(const DateRange& from);
  void MergeFrom(const DateRange& from) { DateRange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DateRange* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.DateRange"; }

 protected:
  explicit DateRange(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DateRange(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DateRange& from);
  DateRange(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DateRange&& from) noexcept
      : DateRange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.DateRange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DateRange& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<41> DateRange_class_data_;
// -------------------------------------------------------------------

class Breakdown final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Breakdown) */ {
 public:
  inline Breakdown() : Breakdown(nullptr) {}
  ~Breakdown() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Breakdown* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Breakdown));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Breakdown(::google::protobuf::internal::ConstantInitialized);

  inline Breakdown(const Breakdown& from) : Breakdown(nullptr, from) {}
  inline Breakdown(Breakdown&& from) noexcept
      : Breakdown(nullptr, std::move(from)) {}
  inline Breakdown& operator=(const Breakdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline Breakdown& operator=(Breakdown&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Breakdown& default_instance() {
    return *reinterpret_cast<const Breakdown*>(
        &_Breakdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Breakdown& a, Breakdown& b) { a.Swap(&b); }
  inline void Swap(Breakdown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Breakdown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Breakdown* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Breakdown>(arena);
  }
  void CopyFrom(const Breakdown& from);
  void MergeFrom(const Breakdown& from) { Breakdown::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Breakdown* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.Breakdown"; }

 protected:
  explicit Breakdown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Breakdown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Breakdown& from);
  Breakdown(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Breakdown&& from) noexcept
      : Breakdown(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Breakdown)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Breakdown& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<41> Breakdown_class_data_;
// -------------------------------------------------------------------

class BinBoundaryDetailedSpec final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec) */ {
 public:
  inline BinBoundaryDetailedSpec() : BinBoundaryDetailedSpec(nullptr) {}
  ~BinBoundaryDetailedSpec() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BinBoundaryDetailedSpec* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BinBoundaryDetailedSpec));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BinBoundaryDetailedSpec(::google::protobuf::internal::ConstantInitialized);

  inline BinBoundaryDetailedSpec(const BinBoundaryDetailedSpec& from) : BinBoundaryDetailedSpec(nullptr, from) {}
  inline BinBoundaryDetailedSpec(BinBoundaryDetailedSpec&& from) noexcept
      : BinBoundaryDetailedSpec(nullptr, std::move(from)) {}
  inline BinBoundaryDetailedSpec& operator=(const BinBoundaryDetailedSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinBoundaryDetailedSpec& operator=(BinBoundaryDetailedSpec&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BinBoundaryDetailedSpec& default_instance() {
    return *reinterpret_cast<const BinBoundaryDetailedSpec*>(
        &_BinBoundaryDetailedSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(BinBoundaryDetailedSpec& a, BinBoundaryDetailedSpec& b) { a.Swap(&b); }
  inline void Swap(BinBoundaryDetailedSpec* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinBoundaryDetailedSpec* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinBoundaryDetailedSpec* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<BinBoundaryDetailedSpec>(arena);
  }
  void CopyFrom(const BinBoundaryDetailedSpec& from);
  void MergeFrom(const BinBoundaryDetailedSpec& from) { BinBoundaryDetailedSpec::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BinBoundaryDetailedSpec* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.BinBoundaryDetailedSpec"; }

 protected:
  explicit BinBoundaryDetailedSpec(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BinBoundaryDetailedSpec(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BinBoundaryDetailedSpec& from);
  BinBoundaryDetailedSpec(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BinBoundaryDetailedSpec&& from) noexcept
      : BinBoundaryDetailedSpec(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------
  using Type = BinBoundaryDetailedSpec_Type;
  static constexpr Type LINEAR = BinBoundaryDetailedSpec_Type_LINEAR;
  static constexpr Type EXPONENTIAL = BinBoundaryDetailedSpec_Type_EXPONENTIAL;
  static inline bool Type_IsValid(int value) {
    return BinBoundaryDetailedSpec_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = BinBoundaryDetailedSpec_Type_Type_MIN;
  static constexpr Type Type_MAX = BinBoundaryDetailedSpec_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = BinBoundaryDetailedSpec_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return BinBoundaryDetailedSpec_Type_Name(value);
  }
  static inline bool Type_Parse(
      absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return BinBoundaryDetailedSpec_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMaximumBinBoundaryFieldNumber = 2,
    kBoundaryTypeFieldNumber = 1,
    kNumBinBoundariesFieldNumber = 3,
  };
  // double maximum_bin_boundary = 2;
  void clear_maximum_bin_boundary() ;
  double maximum_bin_boundary() const;
  void set_maximum_bin_boundary(double value);

  private:
  double _internal_maximum_bin_boundary() const;
  void _internal_set_maximum_bin_boundary(double value);

  public:
  // .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.Type boundary_type = 1;
  void clear_boundary_type() ;
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type boundary_type() const;
  void set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value);

  private:
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type _internal_boundary_type() const;
  void _internal_set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value);

  public:
  // int32 num_bin_boundaries = 3;
  void clear_num_bin_boundaries() ;
  ::int32_t num_bin_boundaries() const;
  void set_num_bin_boundaries(::int32_t value);

  private:
  ::int32_t _internal_num_bin_boundaries() const;
  void _internal_set_num_bin_boundaries(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BinBoundaryDetailedSpec& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double maximum_bin_boundary_;
    int boundary_type_;
    ::int32_t num_bin_boundaries_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<55> BinBoundaryDetailedSpec_class_data_;
// -------------------------------------------------------------------

class Diagnostic final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Diagnostic) */ {
 public:
  inline Diagnostic() : Diagnostic(nullptr) {}
  ~Diagnostic() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Diagnostic* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Diagnostic));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Diagnostic(::google::protobuf::internal::ConstantInitialized);

  inline Diagnostic(const Diagnostic& from) : Diagnostic(nullptr, from) {}
  inline Diagnostic(Diagnostic&& from) noexcept
      : Diagnostic(nullptr, std::move(from)) {}
  inline Diagnostic& operator=(const Diagnostic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Diagnostic& operator=(Diagnostic&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Diagnostic& default_instance() {
    return *reinterpret_cast<const Diagnostic*>(
        &_Diagnostic_default_instance_);
  }
  enum DiagnosticOneofCase {
    kBreakdown = 1,
    kDateRange = 2,
    kGenericSet = 3,
    kRelatedEventSet = 4,
    kRelatedNameMap = 5,
    kScalar = 6,
    kSharedDiagnosticGuid = 7,
    DIAGNOSTIC_ONEOF_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Diagnostic& a, Diagnostic& b) { a.Swap(&b); }
  inline void Swap(Diagnostic* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Diagnostic* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Diagnostic* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Diagnostic>(arena);
  }
  void CopyFrom(const Diagnostic& from);
  void MergeFrom(const Diagnostic& from) { Diagnostic::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Diagnostic* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.Diagnostic"; }

 protected:
  explicit Diagnostic(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Diagnostic(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Diagnostic& from);
  Diagnostic(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Diagnostic&& from) noexcept
      : Diagnostic(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBreakdownFieldNumber = 1,
    kDateRangeFieldNumber = 2,
    kGenericSetFieldNumber = 3,
    kRelatedEventSetFieldNumber = 4,
    kRelatedNameMapFieldNumber = 5,
    kScalarFieldNumber = 6,
    kSharedDiagnosticGuidFieldNumber = 7,
  };
  // .catapult.tracing.tracing.proto.Breakdown breakdown = 1;
  bool has_breakdown() const;
  private:
  bool _internal_has_breakdown() const;

  public:
  void clear_breakdown() ;
  const ::catapult::tracing::tracing::proto::Breakdown& breakdown() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NULLABLE release_breakdown();
  ::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NONNULL mutable_breakdown();
  void set_allocated_breakdown(::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_breakdown(::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NULLABLE unsafe_arena_release_breakdown();

  private:
  const ::catapult::tracing::tracing::proto::Breakdown& _internal_breakdown() const;
  ::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NONNULL _internal_mutable_breakdown();

  public:
  // .catapult.tracing.tracing.proto.DateRange date_range = 2;
  bool has_date_range() const;
  private:
  bool _internal_has_date_range() const;

  public:
  void clear_date_range() ;
  const ::catapult::tracing::tracing::proto::DateRange& date_range() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NULLABLE release_date_range();
  ::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NONNULL mutable_date_range();
  void set_allocated_date_range(::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_date_range(::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NULLABLE unsafe_arena_release_date_range();

  private:
  const ::catapult::tracing::tracing::proto::DateRange& _internal_date_range() const;
  ::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NONNULL _internal_mutable_date_range();

  public:
  // .catapult.tracing.tracing.proto.GenericSet generic_set = 3;
  bool has_generic_set() const;
  private:
  bool _internal_has_generic_set() const;

  public:
  void clear_generic_set() ;
  const ::catapult::tracing::tracing::proto::GenericSet& generic_set() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NULLABLE release_generic_set();
  ::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NONNULL mutable_generic_set();
  void set_allocated_generic_set(::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_generic_set(::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NULLABLE unsafe_arena_release_generic_set();

  private:
  const ::catapult::tracing::tracing::proto::GenericSet& _internal_generic_set() const;
  ::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NONNULL _internal_mutable_generic_set();

  public:
  // .catapult.tracing.tracing.proto.RelatedEventSet related_event_set = 4;
  bool has_related_event_set() const;
  private:
  bool _internal_has_related_event_set() const;

  public:
  void clear_related_event_set() ;
  const ::catapult::tracing::tracing::proto::RelatedEventSet& related_event_set() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NULLABLE release_related_event_set();
  ::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NONNULL mutable_related_event_set();
  void set_allocated_related_event_set(::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_related_event_set(::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NULLABLE unsafe_arena_release_related_event_set();

  private:
  const ::catapult::tracing::tracing::proto::RelatedEventSet& _internal_related_event_set() const;
  ::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NONNULL _internal_mutable_related_event_set();

  public:
  // .catapult.tracing.tracing.proto.RelatedNameMap related_name_map = 5;
  bool has_related_name_map() const;
  private:
  bool _internal_has_related_name_map() const;

  public:
  void clear_related_name_map() ;
  const ::catapult::tracing::tracing::proto::RelatedNameMap& related_name_map() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NULLABLE release_related_name_map();
  ::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NONNULL mutable_related_name_map();
  void set_allocated_related_name_map(::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_related_name_map(::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NULLABLE unsafe_arena_release_related_name_map();

  private:
  const ::catapult::tracing::tracing::proto::RelatedNameMap& _internal_related_name_map() const;
  ::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NONNULL _internal_mutable_related_name_map();

  public:
  // .catapult.tracing.tracing.proto.Scalar scalar = 6;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;

  public:
  void clear_scalar() ;
  const ::catapult::tracing::tracing::proto::Scalar& scalar() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NULLABLE release_scalar();
  ::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NONNULL mutable_scalar();
  void set_allocated_scalar(::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_scalar(::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NULLABLE unsafe_arena_release_scalar();

  private:
  const ::catapult::tracing::tracing::proto::Scalar& _internal_scalar() const;
  ::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NONNULL _internal_mutable_scalar();

  public:
  // string shared_diagnostic_guid = 7;
  bool has_shared_diagnostic_guid() const;
  void clear_shared_diagnostic_guid() ;
  const std::string& shared_diagnostic_guid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shared_diagnostic_guid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_shared_diagnostic_guid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_shared_diagnostic_guid();
  void set_allocated_shared_diagnostic_guid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_shared_diagnostic_guid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_shared_diagnostic_guid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_shared_diagnostic_guid();

  public:
  void clear_diagnostic_oneof();
  DiagnosticOneofCase diagnostic_oneof_case() const;
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Diagnostic)
 private:
  class _Internal;
  void set_has_breakdown();
  void set_has_date_range();
  void set_has_generic_set();
  void set_has_related_event_set();
  void set_has_related_name_map();
  void set_has_scalar();
  void set_has_shared_diagnostic_guid();
  inline bool has_diagnostic_oneof() const;
  inline void clear_has_diagnostic_oneof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 7,
                                   6, 72,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Diagnostic& from_msg);
    union DiagnosticOneofUnion {
      constexpr DiagnosticOneofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE breakdown_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE date_range_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE generic_set_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE related_event_set_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE related_name_map_;
      ::google::protobuf::MessageLite* PROTOBUF_NULLABLE scalar_;
      ::google::protobuf::internal::ArenaStringPtr shared_diagnostic_guid_;
    } diagnostic_oneof_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<42> Diagnostic_class_data_;
// -------------------------------------------------------------------

class BinBoundarySpec final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.BinBoundarySpec) */ {
 public:
  inline BinBoundarySpec() : BinBoundarySpec(nullptr) {}
  ~BinBoundarySpec() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BinBoundarySpec* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BinBoundarySpec));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BinBoundarySpec(::google::protobuf::internal::ConstantInitialized);

  inline BinBoundarySpec(const BinBoundarySpec& from) : BinBoundarySpec(nullptr, from) {}
  inline BinBoundarySpec(BinBoundarySpec&& from) noexcept
      : BinBoundarySpec(nullptr, std::move(from)) {}
  inline BinBoundarySpec& operator=(const BinBoundarySpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinBoundarySpec& operator=(BinBoundarySpec&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BinBoundarySpec& default_instance() {
    return *reinterpret_cast<const BinBoundarySpec*>(
        &_BinBoundarySpec_default_instance_);
  }
  enum BoundaryOneofCase {
    kBinBoundary = 1,
    kBinSpec = 2,
    BOUNDARY_ONEOF_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(BinBoundarySpec& a, BinBoundarySpec& b) { a.Swap(&b); }
  inline void Swap(BinBoundarySpec* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinBoundarySpec* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinBoundarySpec* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<BinBoundarySpec>(arena);
  }
  void CopyFrom(const BinBoundarySpec& from);
  void MergeFrom(const BinBoundarySpec& from) { BinBoundarySpec::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BinBoundarySpec* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.BinBoundarySpec"; }

 protected:
  explicit BinBoundarySpec(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BinBoundarySpec(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BinBoundarySpec& from);
  BinBoundarySpec(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BinBoundarySpec&& from) noexcept
      : BinBoundarySpec(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBinBoundaryFieldNumber = 1,
    kBinSpecFieldNumber = 2,
  };
  // double bin_boundary = 1;
  bool has_bin_boundary() const;
  void clear_bin_boundary() ;
  double bin_boundary() const;
  void set_bin_boundary(double value);

  private:
  double _internal_bin_boundary() const;
  void _internal_set_bin_boundary(double value);

  public:
  // .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec bin_spec = 2;
  bool has_bin_spec() const;
  private:
  bool _internal_has_bin_spec() const;

  public:
  void clear_bin_spec() ;
  const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& bin_spec() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NULLABLE release_bin_spec();
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NONNULL mutable_bin_spec();
  void set_allocated_bin_spec(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bin_spec(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NULLABLE unsafe_arena_release_bin_spec();

  private:
  const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& _internal_bin_spec() const;
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NONNULL _internal_mutable_bin_spec();

  public:
  void clear_boundary_oneof();
  BoundaryOneofCase boundary_oneof_case() const;
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.BinBoundarySpec)
 private:
  class _Internal;
  void set_has_bin_boundary();
  void set_has_bin_spec();
  inline bool has_boundary_oneof() const;
  inline void clear_has_boundary_oneof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BinBoundarySpec& from_msg);
    union BoundaryOneofUnion {
      constexpr BoundaryOneofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      double bin_boundary_;
      ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NULLABLE bin_spec_;
    } boundary_oneof_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<47> BinBoundarySpec_class_data_;
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

class BinBoundaries final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.BinBoundaries) */ {
 public:
  inline BinBoundaries() : BinBoundaries(nullptr) {}
  ~BinBoundaries() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BinBoundaries* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BinBoundaries));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BinBoundaries(::google::protobuf::internal::ConstantInitialized);

  inline BinBoundaries(const BinBoundaries& from) : BinBoundaries(nullptr, from) {}
  inline BinBoundaries(BinBoundaries&& from) noexcept
      : BinBoundaries(nullptr, std::move(from)) {}
  inline BinBoundaries& operator=(const BinBoundaries& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinBoundaries& operator=(BinBoundaries&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BinBoundaries& default_instance() {
    return *reinterpret_cast<const BinBoundaries*>(
        &_BinBoundaries_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(BinBoundaries& a, BinBoundaries& b) { a.Swap(&b); }
  inline void Swap(BinBoundaries* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinBoundaries* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinBoundaries* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<BinBoundaries>(arena);
  }
  void CopyFrom(const BinBoundaries& from);
  void MergeFrom(const BinBoundaries& from) { BinBoundaries::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BinBoundaries* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.BinBoundaries"; }

 protected:
  explicit BinBoundaries(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BinBoundaries(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BinBoundaries& from);
  BinBoundaries(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BinBoundaries&& from) noexcept
      : BinBoundaries(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBinSpecsFieldNumber = 2,
    kFirstBinBoundaryFieldNumber = 1,
  };
  // repeated .catapult.tracing.tracing.proto.BinBoundarySpec bin_specs = 2;
  int bin_specs_size() const;
  private:
  int _internal_bin_specs_size() const;

  public:
  void clear_bin_specs() ;
  ::catapult::tracing::tracing::proto::BinBoundarySpec* PROTOBUF_NONNULL mutable_bin_specs(int index);
  ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::BinBoundarySpec>* PROTOBUF_NONNULL mutable_bin_specs();

  private:
  const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::BinBoundarySpec>& _internal_bin_specs() const;
  ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::BinBoundarySpec>* PROTOBUF_NONNULL _internal_mutable_bin_specs();
  public:
  const ::catapult::tracing::tracing::proto::BinBoundarySpec& bin_specs(int index) const;
  ::catapult::tracing::tracing::proto::BinBoundarySpec* PROTOBUF_NONNULL add_bin_specs();
  const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::BinBoundarySpec>& bin_specs() const;
  // double first_bin_boundary = 1;
  void clear_first_bin_boundary() ;
  double first_bin_boundary() const;
  void set_first_bin_boundary(double value);

  private:
  double _internal_first_bin_boundary() const;
  void _internal_set_first_bin_boundary(double value);

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.BinBoundaries)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BinBoundaries& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::catapult::tracing::tracing::proto::BinBoundarySpec > bin_specs_;
    double first_bin_boundary_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<45> BinBoundaries_class_data_;
// -------------------------------------------------------------------

class DiagnosticMap final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.DiagnosticMap) */ {
 public:
  inline DiagnosticMap() : DiagnosticMap(nullptr) {}
  ~DiagnosticMap() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiagnosticMap* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiagnosticMap));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiagnosticMap(::google::protobuf::internal::ConstantInitialized);

  inline DiagnosticMap(const DiagnosticMap& from) : DiagnosticMap(nullptr, from) {}
  inline DiagnosticMap(DiagnosticMap&& from) noexcept
      : DiagnosticMap(nullptr, std::move(from)) {}
  inline DiagnosticMap& operator=(const DiagnosticMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiagnosticMap& operator=(DiagnosticMap&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DiagnosticMap& default_instance() {
    return *reinterpret_cast<const DiagnosticMap*>(
        &_DiagnosticMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(DiagnosticMap& a, DiagnosticMap& b) { a.Swap(&b); }
  inline void Swap(DiagnosticMap* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiagnosticMap* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiagnosticMap* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<DiagnosticMap>(arena);
  }
  void CopyFrom(const DiagnosticMap& from);
  void MergeFrom(const DiagnosticMap& from) { DiagnosticMap::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiagnosticMap* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.DiagnosticMap"; }

 protected:
  explicit DiagnosticMap(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiagnosticMap(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiagnosticMap& from);
  DiagnosticMap(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiagnosticMap&& from) noexcept
      : DiagnosticMap(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDiagnosticMapFieldNumber = 1,
  };
  // map<string, .catapult.tracing.tracing.proto.Diagnostic> diagnostic_map = 1;
  int diagnostic_map_size() const;
  private:
  int _internal_diagnostic_map_size() const;

  public:
  void clear_diagnostic_map() ;
  const ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>& diagnostic_map() const;
  ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>* PROTOBUF_NONNULL mutable_diagnostic_map();

  private:
  const ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>& _internal_diagnostic_map() const;
  ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>* PROTOBUF_NONNULL _internal_mutable_diagnostic_map();

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.DiagnosticMap)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   2, 67,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiagnosticMap& from_msg);
    ::google::protobuf::internal::MapFieldLite<std::string, ::catapult::tracing::tracing::proto::Diagnostic> diagnostic_map_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<45> DiagnosticMap_class_data_;
// -------------------------------------------------------------------

class Bin final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Bin) */ {
 public:
  inline Bin() : Bin(nullptr) {}
  ~Bin() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Bin* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Bin));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Bin(::google::protobuf::internal::ConstantInitialized);

  inline Bin(const Bin& from) : Bin(nullptr, from) {}
  inline Bin(Bin&& from) noexcept
      : Bin(nullptr, std::move(from)) {}
  inline Bin& operator=(const Bin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bin& operator=(Bin&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Bin& default_instance() {
    return *reinterpret_cast<const Bin*>(
        &_Bin_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Bin& a, Bin& b) { a.Swap(&b); }
  inline void Swap(Bin* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bin* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bin* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Bin>(arena);
  }
  void CopyFrom(const Bin& from);
  void MergeFrom(const Bin& from) { Bin::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Bin* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.Bin"; }

 protected:
  explicit Bin(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Bin(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Bin& from);
  Bin(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Bin&& from) noexcept
      : Bin(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDiagnosticMapsFieldNumber = 2,
    kBinCountFieldNumber = 1,
  };
  // repeated .catapult.tracing.tracing.proto.DiagnosticMap diagnostic_maps = 2;
  int diagnostic_maps_size() const;
  private:
  int _internal_diagnostic_maps_size() const;

  public:
  void clear_diagnostic_maps() ;
  ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL mutable_diagnostic_maps(int index);
  ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>* PROTOBUF_NONNULL mutable_diagnostic_maps();

  private:
  const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>& _internal_diagnostic_maps() const;
  ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>* PROTOBUF_NONNULL _internal_mutable_diagnostic_maps();
  public:
  const ::catapult::tracing::tracing::proto::DiagnosticMap& diagnostic_maps(int index) const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL add_diagnostic_maps();
  const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>& diagnostic_maps() const;
  // int32 bin_count = 1;
  void clear_bin_count() ;
  ::int32_t bin_count() const;
  void set_bin_count(::int32_t value);

  private:
  ::int32_t _internal_bin_count() const;
  void _internal_set_bin_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Bin)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Bin& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap > diagnostic_maps_;
    ::int32_t bin_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<35> Bin_class_data_;
// -------------------------------------------------------------------

// -------------------------------------------------------------------

class Histogram final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.Histogram) */ {
 public:
  inline Histogram() : Histogram(nullptr) {}
  ~Histogram() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Histogram* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Histogram));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Histogram(::google::protobuf::internal::ConstantInitialized);

  inline Histogram(const Histogram& from) : Histogram(nullptr, from) {}
  inline Histogram(Histogram&& from) noexcept
      : Histogram(nullptr, std::move(from)) {}
  inline Histogram& operator=(const Histogram& from) {
    CopyFrom(from);
    return *this;
  }
  inline Histogram& operator=(Histogram&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Histogram& default_instance() {
    return *reinterpret_cast<const Histogram*>(
        &_Histogram_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(Histogram& a, Histogram& b) { a.Swap(&b); }
  inline void Swap(Histogram* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Histogram* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Histogram* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Histogram>(arena);
  }
  void CopyFrom(const Histogram& from);
  void MergeFrom(const Histogram& from) { Histogram::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Histogram* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.Histogram"; }

 protected:
  explicit Histogram(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Histogram(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Histogram& from);
  Histogram(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Histogram&& from) noexcept
      : Histogram(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSampleValuesFieldNumber = 6,
    kNanDiagnosticsFieldNumber = 9,
    kAllBinsFieldNumber = 11,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 4,
    kUnitFieldNumber = 2,
    kBinBoundariesFieldNumber = 3,
    kDiagnosticsFieldNumber = 5,
    kRunningFieldNumber = 10,
    kSummaryOptionsFieldNumber = 12,
    kMaxNumSampleValuesFieldNumber = 7,
    kNumNansFieldNumber = 8,
  };
  // repeated double sample_values = 6;
  int sample_values_size() const;
  private:
  int _internal_sample_values_size() const;

  public:
  void clear_sample_values() ;
  double sample_values(int index) const;
  void set_sample_values(int index, double value);
  void add_sample_values(double value);
  const ::google::protobuf::RepeatedField<double>& sample_values() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL mutable_sample_values();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_sample_values() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL _internal_mutable_sample_values();

  public:
  // repeated .catapult.tracing.tracing.proto.DiagnosticMap nan_diagnostics = 9;
  int nan_diagnostics_size() const;
  private:
  int _internal_nan_diagnostics_size() const;

  public:
  void clear_nan_diagnostics() ;
  ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL mutable_nan_diagnostics(int index);
  ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>* PROTOBUF_NONNULL mutable_nan_diagnostics();

  private:
  const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>& _internal_nan_diagnostics() const;
  ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>* PROTOBUF_NONNULL _internal_mutable_nan_diagnostics();
  public:
  const ::catapult::tracing::tracing::proto::DiagnosticMap& nan_diagnostics(int index) const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL add_nan_diagnostics();
  const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>& nan_diagnostics() const;
  // map<int32, .catapult.tracing.tracing.proto.Bin> all_bins = 11;
  int all_bins_size() const;
  private:
  int _internal_all_bins_size() const;

  public:
  void clear_all_bins() ;
  const ::google::protobuf::Map<::int32_t, ::catapult::tracing::tracing::proto::Bin>& all_bins() const;
  ::google::protobuf::Map<::int32_t, ::catapult::tracing::tracing::proto::Bin>* PROTOBUF_NONNULL mutable_all_bins();

  private:
  const ::google::protobuf::Map<::int32_t, ::catapult::tracing::tracing::proto::Bin>& _internal_all_bins() const;
  ::google::protobuf::Map<::int32_t, ::catapult::tracing::tracing::proto::Bin>* PROTOBUF_NONNULL _internal_mutable_all_bins();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string description = 4;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // .catapult.tracing.tracing.proto.UnitAndDirection unit = 2;
  bool has_unit() const;
  void clear_unit() ;
  const ::catapult::tracing::tracing::proto::UnitAndDirection& unit() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NULLABLE release_unit();
  ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NONNULL mutable_unit();
  void set_allocated_unit(::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_unit(::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NULLABLE unsafe_arena_release_unit();

  private:
  const ::catapult::tracing::tracing::proto::UnitAndDirection& _internal_unit() const;
  ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NONNULL _internal_mutable_unit();

  public:
  // .catapult.tracing.tracing.proto.BinBoundaries bin_boundaries = 3;
  bool has_bin_boundaries() const;
  void clear_bin_boundaries() ;
  const ::catapult::tracing::tracing::proto::BinBoundaries& bin_boundaries() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NULLABLE release_bin_boundaries();
  ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NONNULL mutable_bin_boundaries();
  void set_allocated_bin_boundaries(::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bin_boundaries(::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NULLABLE unsafe_arena_release_bin_boundaries();

  private:
  const ::catapult::tracing::tracing::proto::BinBoundaries& _internal_bin_boundaries() const;
  ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NONNULL _internal_mutable_bin_boundaries();

  public:
  // .catapult.tracing.tracing.proto.DiagnosticMap diagnostics = 5;
  bool has_diagnostics() const;
  void clear_diagnostics() ;
  const ::catapult::tracing::tracing::proto::DiagnosticMap& diagnostics() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NULLABLE release_diagnostics();
  ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL mutable_diagnostics();
  void set_allocated_diagnostics(::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_diagnostics(::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NULLABLE unsafe_arena_release_diagnostics();

  private:
  const ::catapult::tracing::tracing::proto::DiagnosticMap& _internal_diagnostics() const;
  ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL _internal_mutable_diagnostics();

  public:
  // .catapult.tracing.tracing.proto.RunningStatistics running = 10;
  bool has_running() const;
  void clear_running() ;
  const ::catapult::tracing::tracing::proto::RunningStatistics& running() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NULLABLE release_running();
  ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NONNULL mutable_running();
  void set_allocated_running(::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_running(::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NULLABLE unsafe_arena_release_running();

  private:
  const ::catapult::tracing::tracing::proto::RunningStatistics& _internal_running() const;
  ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NONNULL _internal_mutable_running();

  public:
  // .catapult.tracing.tracing.proto.SummaryOptions summary_options = 12;
  bool has_summary_options() const;
  void clear_summary_options() ;
  const ::catapult::tracing::tracing::proto::SummaryOptions& summary_options() const;
  [[nodiscard]] ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NULLABLE release_summary_options();
  ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NONNULL mutable_summary_options();
  void set_allocated_summary_options(::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_summary_options(::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NULLABLE value);
  ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NULLABLE unsafe_arena_release_summary_options();

  private:
  const ::catapult::tracing::tracing::proto::SummaryOptions& _internal_summary_options() const;
  ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NONNULL _internal_mutable_summary_options();

  public:
  // int32 max_num_sample_values = 7;
  void clear_max_num_sample_values() ;
  ::int32_t max_num_sample_values() const;
  void set_max_num_sample_values(::int32_t value);

  private:
  ::int32_t _internal_max_num_sample_values() const;
  void _internal_set_max_num_sample_values(::int32_t value);

  public:
  // int32 num_nans = 8;
  void clear_num_nans() ;
  ::int32_t num_nans() const;
  void set_num_nans(::int32_t value);

  private:
  ::int32_t _internal_num_nans() const;
  void _internal_set_num_nans(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.Histogram)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12,
                                   8, 72,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Histogram& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> sample_values_;
    ::google::protobuf::RepeatedPtrField< ::catapult::tracing::tracing::proto::DiagnosticMap > nan_diagnostics_;
    ::google::protobuf::internal::MapFieldLite<::int32_t, ::catapult::tracing::tracing::proto::Bin> all_bins_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NULLABLE unit_;
    ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NULLABLE bin_boundaries_;
    ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NULLABLE diagnostics_;
    ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NULLABLE running_;
    ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NULLABLE summary_options_;
    ::int32_t max_num_sample_values_;
    ::int32_t num_nans_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<41> Histogram_class_data_;
// -------------------------------------------------------------------

class HistogramSet final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:catapult.tracing.tracing.proto.HistogramSet) */ {
 public:
  inline HistogramSet() : HistogramSet(nullptr) {}
  ~HistogramSet() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HistogramSet* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HistogramSet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HistogramSet(::google::protobuf::internal::ConstantInitialized);

  inline HistogramSet(const HistogramSet& from) : HistogramSet(nullptr, from) {}
  inline HistogramSet(HistogramSet&& from) noexcept
      : HistogramSet(nullptr, std::move(from)) {}
  inline HistogramSet& operator=(const HistogramSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistogramSet& operator=(HistogramSet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HistogramSet& default_instance() {
    return *reinterpret_cast<const HistogramSet*>(
        &_HistogramSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(HistogramSet& a, HistogramSet& b) { a.Swap(&b); }
  inline void Swap(HistogramSet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistogramSet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistogramSet* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<HistogramSet>(arena);
  }
  void CopyFrom(const HistogramSet& from);
  void MergeFrom(const HistogramSet& from) { HistogramSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HistogramSet* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "catapult.tracing.tracing.proto.HistogramSet"; }

 protected:
  explicit HistogramSet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HistogramSet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HistogramSet& from);
  HistogramSet(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HistogramSet&& from) noexcept
      : HistogramSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHistogramsFieldNumber = 1,
    kSharedDiagnosticsFieldNumber = 2,
  };
  // repeated .catapult.tracing.tracing.proto.Histogram histograms = 1;
  int histograms_size() const;
  private:
  int _internal_histograms_size() const;

  public:
  void clear_histograms() ;
  ::catapult::tracing::tracing::proto::Histogram* PROTOBUF_NONNULL mutable_histograms(int index);
  ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::Histogram>* PROTOBUF_NONNULL mutable_histograms();

  private:
  const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::Histogram>& _internal_histograms() const;
  ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::Histogram>* PROTOBUF_NONNULL _internal_mutable_histograms();
  public:
  const ::catapult::tracing::tracing::proto::Histogram& histograms(int index) const;
  ::catapult::tracing::tracing::proto::Histogram* PROTOBUF_NONNULL add_histograms();
  const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::Histogram>& histograms() const;
  // map<string, .catapult.tracing.tracing.proto.Diagnostic> shared_diagnostics = 2;
  int shared_diagnostics_size() const;
  private:
  int _internal_shared_diagnostics_size() const;

  public:
  void clear_shared_diagnostics() ;
  const ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>& shared_diagnostics() const;
  ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>* PROTOBUF_NONNULL mutable_shared_diagnostics();

  private:
  const ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>& _internal_shared_diagnostics() const;
  ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>* PROTOBUF_NONNULL _internal_mutable_shared_diagnostics();

  public:
  // @@protoc_insertion_point(class_scope:catapult.tracing.tracing.proto.HistogramSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   3, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HistogramSet& from_msg);
    ::google::protobuf::RepeatedPtrField< ::catapult::tracing::tracing::proto::Histogram > histograms_;
    ::google::protobuf::internal::MapFieldLite<std::string, ::catapult::tracing::tracing::proto::Diagnostic> shared_diagnostics_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_histogram_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<44> HistogramSet_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UnitAndDirection

// .catapult.tracing.tracing.proto.Unit unit = 1;
inline void UnitAndDirection::clear_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::catapult::tracing::tracing::proto::Unit UnitAndDirection::unit() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.UnitAndDirection.unit)
  return _internal_unit();
}
inline void UnitAndDirection::set_unit(::catapult::tracing::tracing::proto::Unit value) {
  _internal_set_unit(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.UnitAndDirection.unit)
}
inline ::catapult::tracing::tracing::proto::Unit UnitAndDirection::_internal_unit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::catapult::tracing::tracing::proto::Unit>(_impl_.unit_);
}
inline void UnitAndDirection::_internal_set_unit(::catapult::tracing::tracing::proto::Unit value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unit_ = value;
}

// .catapult.tracing.tracing.proto.ImprovementDirection improvement_direction = 2;
inline void UnitAndDirection::clear_improvement_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.improvement_direction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::catapult::tracing::tracing::proto::ImprovementDirection UnitAndDirection::improvement_direction() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.UnitAndDirection.improvement_direction)
  return _internal_improvement_direction();
}
inline void UnitAndDirection::set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value) {
  _internal_set_improvement_direction(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.UnitAndDirection.improvement_direction)
}
inline ::catapult::tracing::tracing::proto::ImprovementDirection UnitAndDirection::_internal_improvement_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::catapult::tracing::tracing::proto::ImprovementDirection>(_impl_.improvement_direction_);
}
inline void UnitAndDirection::_internal_set_improvement_direction(::catapult::tracing::tracing::proto::ImprovementDirection value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.improvement_direction_ = value;
}

// -------------------------------------------------------------------

// BinBoundaryDetailedSpec

// .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.Type boundary_type = 1;
inline void BinBoundaryDetailedSpec::clear_boundary_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.boundary_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec::boundary_type() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.boundary_type)
  return _internal_boundary_type();
}
inline void BinBoundaryDetailedSpec::set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value) {
  _internal_set_boundary_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.boundary_type)
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type BinBoundaryDetailedSpec::_internal_boundary_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type>(_impl_.boundary_type_);
}
inline void BinBoundaryDetailedSpec::_internal_set_boundary_type(::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.boundary_type_ = value;
}

// double maximum_bin_boundary = 2;
inline void BinBoundaryDetailedSpec::clear_maximum_bin_boundary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maximum_bin_boundary_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double BinBoundaryDetailedSpec::maximum_bin_boundary() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.maximum_bin_boundary)
  return _internal_maximum_bin_boundary();
}
inline void BinBoundaryDetailedSpec::set_maximum_bin_boundary(double value) {
  _internal_set_maximum_bin_boundary(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.maximum_bin_boundary)
}
inline double BinBoundaryDetailedSpec::_internal_maximum_bin_boundary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maximum_bin_boundary_;
}
inline void BinBoundaryDetailedSpec::_internal_set_maximum_bin_boundary(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maximum_bin_boundary_ = value;
}

// int32 num_bin_boundaries = 3;
inline void BinBoundaryDetailedSpec::clear_num_bin_boundaries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_bin_boundaries_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t BinBoundaryDetailedSpec::num_bin_boundaries() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.num_bin_boundaries)
  return _internal_num_bin_boundaries();
}
inline void BinBoundaryDetailedSpec::set_num_bin_boundaries(::int32_t value) {
  _internal_set_num_bin_boundaries(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaryDetailedSpec.num_bin_boundaries)
}
inline ::int32_t BinBoundaryDetailedSpec::_internal_num_bin_boundaries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_bin_boundaries_;
}
inline void BinBoundaryDetailedSpec::_internal_set_num_bin_boundaries(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_bin_boundaries_ = value;
}

// -------------------------------------------------------------------

// BinBoundarySpec

// double bin_boundary = 1;
inline bool BinBoundarySpec::has_bin_boundary() const {
  return boundary_oneof_case() == kBinBoundary;
}
inline void BinBoundarySpec::set_has_bin_boundary() {
  _impl_._oneof_case_[0] = kBinBoundary;
}
inline void BinBoundarySpec::clear_bin_boundary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (boundary_oneof_case() == kBinBoundary) {
    _impl_.boundary_oneof_.bin_boundary_ = 0;
    clear_has_boundary_oneof();
  }
}
inline double BinBoundarySpec::bin_boundary() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundarySpec.bin_boundary)
  return _internal_bin_boundary();
}
inline void BinBoundarySpec::set_bin_boundary(double value) {
  if (boundary_oneof_case() != kBinBoundary) {
    clear_boundary_oneof();
    set_has_bin_boundary();
  }
  _impl_.boundary_oneof_.bin_boundary_ = value;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundarySpec.bin_boundary)
}
inline double BinBoundarySpec::_internal_bin_boundary() const {
  if (boundary_oneof_case() == kBinBoundary) {
    return _impl_.boundary_oneof_.bin_boundary_;
  }
  return 0;
}

// .catapult.tracing.tracing.proto.BinBoundaryDetailedSpec bin_spec = 2;
inline bool BinBoundarySpec::has_bin_spec() const {
  return boundary_oneof_case() == kBinSpec;
}
inline bool BinBoundarySpec::_internal_has_bin_spec() const {
  return boundary_oneof_case() == kBinSpec;
}
inline void BinBoundarySpec::set_has_bin_spec() {
  _impl_._oneof_case_[0] = kBinSpec;
}
inline void BinBoundarySpec::clear_bin_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (boundary_oneof_case() == kBinSpec) {
    if (GetArena() == nullptr) {
      delete _impl_.boundary_oneof_.bin_spec_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.boundary_oneof_.bin_spec_ != nullptr) {
        _impl_.boundary_oneof_.bin_spec_->Clear();
      }
    }
    clear_has_boundary_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NULLABLE BinBoundarySpec::release_bin_spec() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  if (boundary_oneof_case() == kBinSpec) {
    clear_has_boundary_oneof();
    auto* temp = _impl_.boundary_oneof_.bin_spec_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.boundary_oneof_.bin_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& BinBoundarySpec::_internal_bin_spec() const {
  return boundary_oneof_case() == kBinSpec ? *_impl_.boundary_oneof_.bin_spec_ : reinterpret_cast<::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec&>(::catapult::tracing::tracing::proto::_BinBoundaryDetailedSpec_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec& BinBoundarySpec::bin_spec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  return _internal_bin_spec();
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NULLABLE BinBoundarySpec::unsafe_arena_release_bin_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  if (boundary_oneof_case() == kBinSpec) {
    clear_has_boundary_oneof();
    auto* temp = _impl_.boundary_oneof_.bin_spec_;
    _impl_.boundary_oneof_.bin_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BinBoundarySpec::unsafe_arena_set_allocated_bin_spec(
    ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_boundary_oneof();
  if (value) {
    set_has_bin_spec();
    _impl_.boundary_oneof_.bin_spec_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NONNULL BinBoundarySpec::_internal_mutable_bin_spec() {
  if (boundary_oneof_case() != kBinSpec) {
    clear_boundary_oneof();
    set_has_bin_spec();
    _impl_.boundary_oneof_.bin_spec_ = 
        ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec>(GetArena());
  }
  return _impl_.boundary_oneof_.bin_spec_;
}
inline ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* PROTOBUF_NONNULL BinBoundarySpec::mutable_bin_spec()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec* _msg = _internal_mutable_bin_spec();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.BinBoundarySpec.bin_spec)
  return _msg;
}

inline bool BinBoundarySpec::has_boundary_oneof() const {
  return boundary_oneof_case() != BOUNDARY_ONEOF_NOT_SET;
}
inline void BinBoundarySpec::clear_has_boundary_oneof() {
  _impl_._oneof_case_[0] = BOUNDARY_ONEOF_NOT_SET;
}
inline BinBoundarySpec::BoundaryOneofCase BinBoundarySpec::boundary_oneof_case() const {
  return BinBoundarySpec::BoundaryOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BinBoundaries

// double first_bin_boundary = 1;
inline void BinBoundaries::clear_first_bin_boundary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_bin_boundary_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double BinBoundaries::first_bin_boundary() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaries.first_bin_boundary)
  return _internal_first_bin_boundary();
}
inline void BinBoundaries::set_first_bin_boundary(double value) {
  _internal_set_first_bin_boundary(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.BinBoundaries.first_bin_boundary)
}
inline double BinBoundaries::_internal_first_bin_boundary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.first_bin_boundary_;
}
inline void BinBoundaries::_internal_set_first_bin_boundary(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_bin_boundary_ = value;
}

// repeated .catapult.tracing.tracing.proto.BinBoundarySpec bin_specs = 2;
inline int BinBoundaries::_internal_bin_specs_size() const {
  return _internal_bin_specs().size();
}
inline int BinBoundaries::bin_specs_size() const {
  return _internal_bin_specs_size();
}
inline void BinBoundaries::clear_bin_specs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bin_specs_.Clear();
}
inline ::catapult::tracing::tracing::proto::BinBoundarySpec* PROTOBUF_NONNULL BinBoundaries::mutable_bin_specs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return _internal_mutable_bin_specs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::BinBoundarySpec>* PROTOBUF_NONNULL BinBoundaries::mutable_bin_specs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bin_specs();
}
inline const ::catapult::tracing::tracing::proto::BinBoundarySpec& BinBoundaries::bin_specs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return _internal_bin_specs().Get(index);
}
inline ::catapult::tracing::tracing::proto::BinBoundarySpec* PROTOBUF_NONNULL BinBoundaries::add_bin_specs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::catapult::tracing::tracing::proto::BinBoundarySpec* _add = _internal_mutable_bin_specs()->Add();
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::BinBoundarySpec>& BinBoundaries::bin_specs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.BinBoundaries.bin_specs)
  return _internal_bin_specs();
}
inline const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::BinBoundarySpec>&
BinBoundaries::_internal_bin_specs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bin_specs_;
}
inline ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::BinBoundarySpec>* PROTOBUF_NONNULL
BinBoundaries::_internal_mutable_bin_specs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bin_specs_;
}

// -------------------------------------------------------------------

// Breakdown

// -------------------------------------------------------------------

// DateRange

// -------------------------------------------------------------------

// GenericSet

// repeated string values = 1;
inline int GenericSet::_internal_values_size() const {
  return _internal_values().size();
}
inline int GenericSet::values_size() const {
  return _internal_values_size();
}
inline void GenericSet::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline std::string* PROTOBUF_NONNULL GenericSet::add_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add_mutable:catapult.tracing.tracing.proto.GenericSet.values)
  return _s;
}
inline const std::string& GenericSet::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.GenericSet.values)
  return _internal_values().Get(index);
}
inline std::string* PROTOBUF_NONNULL GenericSet::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.GenericSet.values)
  return _internal_mutable_values()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GenericSet::set_values(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_values()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.GenericSet.values)
}
template <typename Arg_, typename... Args_>
inline void GenericSet::add_values(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_values(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.GenericSet.values)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& GenericSet::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.GenericSet.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
GenericSet::mutable_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.GenericSet.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GenericSet::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
GenericSet::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// RelatedEventSet

// -------------------------------------------------------------------

// RelatedNameMap

// -------------------------------------------------------------------

// Scalar

// -------------------------------------------------------------------

// Diagnostic

// .catapult.tracing.tracing.proto.Breakdown breakdown = 1;
inline bool Diagnostic::has_breakdown() const {
  return diagnostic_oneof_case() == kBreakdown;
}
inline bool Diagnostic::_internal_has_breakdown() const {
  return diagnostic_oneof_case() == kBreakdown;
}
inline void Diagnostic::set_has_breakdown() {
  _impl_._oneof_case_[0] = kBreakdown;
}
inline void Diagnostic::clear_breakdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() == kBreakdown) {
    if (GetArena() == nullptr) {
      delete _impl_.diagnostic_oneof_.breakdown_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.diagnostic_oneof_.breakdown_ != nullptr) {
        _impl_.diagnostic_oneof_.breakdown_->Clear();
      }
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NULLABLE Diagnostic::release_breakdown() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  if (diagnostic_oneof_case() == kBreakdown) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::Breakdown*>(_impl_.diagnostic_oneof_.breakdown_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.diagnostic_oneof_.breakdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::Breakdown& Diagnostic::_internal_breakdown() const {
  return diagnostic_oneof_case() == kBreakdown ? *reinterpret_cast<::catapult::tracing::tracing::proto::Breakdown*>(_impl_.diagnostic_oneof_.breakdown_) : reinterpret_cast<::catapult::tracing::tracing::proto::Breakdown&>(::catapult::tracing::tracing::proto::_Breakdown_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::Breakdown& Diagnostic::breakdown() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  return _internal_breakdown();
}
inline ::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NULLABLE Diagnostic::unsafe_arena_release_breakdown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  if (diagnostic_oneof_case() == kBreakdown) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::Breakdown*>(_impl_.diagnostic_oneof_.breakdown_);
    _impl_.diagnostic_oneof_.breakdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_breakdown(
    ::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_diagnostic_oneof();
  if (value) {
    set_has_breakdown();
    _impl_.diagnostic_oneof_.breakdown_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.breakdown)
}
inline ::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NONNULL Diagnostic::_internal_mutable_breakdown() {
  if (diagnostic_oneof_case() != kBreakdown) {
    clear_diagnostic_oneof();
    set_has_breakdown();
    _impl_.diagnostic_oneof_.breakdown_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::Breakdown>(GetArena()));
  }
  return reinterpret_cast<::catapult::tracing::tracing::proto::Breakdown*>(_impl_.diagnostic_oneof_.breakdown_);
}
inline ::catapult::tracing::tracing::proto::Breakdown* PROTOBUF_NONNULL Diagnostic::mutable_breakdown()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::catapult::tracing::tracing::proto::Breakdown* _msg = _internal_mutable_breakdown();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.breakdown)
  return _msg;
}

// .catapult.tracing.tracing.proto.DateRange date_range = 2;
inline bool Diagnostic::has_date_range() const {
  return diagnostic_oneof_case() == kDateRange;
}
inline bool Diagnostic::_internal_has_date_range() const {
  return diagnostic_oneof_case() == kDateRange;
}
inline void Diagnostic::set_has_date_range() {
  _impl_._oneof_case_[0] = kDateRange;
}
inline void Diagnostic::clear_date_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() == kDateRange) {
    if (GetArena() == nullptr) {
      delete _impl_.diagnostic_oneof_.date_range_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.diagnostic_oneof_.date_range_ != nullptr) {
        _impl_.diagnostic_oneof_.date_range_->Clear();
      }
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NULLABLE Diagnostic::release_date_range() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.date_range)
  if (diagnostic_oneof_case() == kDateRange) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::DateRange*>(_impl_.diagnostic_oneof_.date_range_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.diagnostic_oneof_.date_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::DateRange& Diagnostic::_internal_date_range() const {
  return diagnostic_oneof_case() == kDateRange ? *reinterpret_cast<::catapult::tracing::tracing::proto::DateRange*>(_impl_.diagnostic_oneof_.date_range_) : reinterpret_cast<::catapult::tracing::tracing::proto::DateRange&>(::catapult::tracing::tracing::proto::_DateRange_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::DateRange& Diagnostic::date_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.date_range)
  return _internal_date_range();
}
inline ::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NULLABLE Diagnostic::unsafe_arena_release_date_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.date_range)
  if (diagnostic_oneof_case() == kDateRange) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::DateRange*>(_impl_.diagnostic_oneof_.date_range_);
    _impl_.diagnostic_oneof_.date_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_date_range(
    ::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_diagnostic_oneof();
  if (value) {
    set_has_date_range();
    _impl_.diagnostic_oneof_.date_range_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.date_range)
}
inline ::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NONNULL Diagnostic::_internal_mutable_date_range() {
  if (diagnostic_oneof_case() != kDateRange) {
    clear_diagnostic_oneof();
    set_has_date_range();
    _impl_.diagnostic_oneof_.date_range_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::DateRange>(GetArena()));
  }
  return reinterpret_cast<::catapult::tracing::tracing::proto::DateRange*>(_impl_.diagnostic_oneof_.date_range_);
}
inline ::catapult::tracing::tracing::proto::DateRange* PROTOBUF_NONNULL Diagnostic::mutable_date_range()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::catapult::tracing::tracing::proto::DateRange* _msg = _internal_mutable_date_range();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.date_range)
  return _msg;
}

// .catapult.tracing.tracing.proto.GenericSet generic_set = 3;
inline bool Diagnostic::has_generic_set() const {
  return diagnostic_oneof_case() == kGenericSet;
}
inline bool Diagnostic::_internal_has_generic_set() const {
  return diagnostic_oneof_case() == kGenericSet;
}
inline void Diagnostic::set_has_generic_set() {
  _impl_._oneof_case_[0] = kGenericSet;
}
inline void Diagnostic::clear_generic_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() == kGenericSet) {
    if (GetArena() == nullptr) {
      delete _impl_.diagnostic_oneof_.generic_set_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.diagnostic_oneof_.generic_set_ != nullptr) {
        _impl_.diagnostic_oneof_.generic_set_->Clear();
      }
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NULLABLE Diagnostic::release_generic_set() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  if (diagnostic_oneof_case() == kGenericSet) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::GenericSet*>(_impl_.diagnostic_oneof_.generic_set_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.diagnostic_oneof_.generic_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::GenericSet& Diagnostic::_internal_generic_set() const {
  return diagnostic_oneof_case() == kGenericSet ? *reinterpret_cast<::catapult::tracing::tracing::proto::GenericSet*>(_impl_.diagnostic_oneof_.generic_set_) : reinterpret_cast<::catapult::tracing::tracing::proto::GenericSet&>(::catapult::tracing::tracing::proto::_GenericSet_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::GenericSet& Diagnostic::generic_set() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  return _internal_generic_set();
}
inline ::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NULLABLE Diagnostic::unsafe_arena_release_generic_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  if (diagnostic_oneof_case() == kGenericSet) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::GenericSet*>(_impl_.diagnostic_oneof_.generic_set_);
    _impl_.diagnostic_oneof_.generic_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_generic_set(
    ::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_diagnostic_oneof();
  if (value) {
    set_has_generic_set();
    _impl_.diagnostic_oneof_.generic_set_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.generic_set)
}
inline ::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NONNULL Diagnostic::_internal_mutable_generic_set() {
  if (diagnostic_oneof_case() != kGenericSet) {
    clear_diagnostic_oneof();
    set_has_generic_set();
    _impl_.diagnostic_oneof_.generic_set_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::GenericSet>(GetArena()));
  }
  return reinterpret_cast<::catapult::tracing::tracing::proto::GenericSet*>(_impl_.diagnostic_oneof_.generic_set_);
}
inline ::catapult::tracing::tracing::proto::GenericSet* PROTOBUF_NONNULL Diagnostic::mutable_generic_set()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::catapult::tracing::tracing::proto::GenericSet* _msg = _internal_mutable_generic_set();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.generic_set)
  return _msg;
}

// .catapult.tracing.tracing.proto.RelatedEventSet related_event_set = 4;
inline bool Diagnostic::has_related_event_set() const {
  return diagnostic_oneof_case() == kRelatedEventSet;
}
inline bool Diagnostic::_internal_has_related_event_set() const {
  return diagnostic_oneof_case() == kRelatedEventSet;
}
inline void Diagnostic::set_has_related_event_set() {
  _impl_._oneof_case_[0] = kRelatedEventSet;
}
inline void Diagnostic::clear_related_event_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() == kRelatedEventSet) {
    if (GetArena() == nullptr) {
      delete _impl_.diagnostic_oneof_.related_event_set_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.diagnostic_oneof_.related_event_set_ != nullptr) {
        _impl_.diagnostic_oneof_.related_event_set_->Clear();
      }
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NULLABLE Diagnostic::release_related_event_set() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  if (diagnostic_oneof_case() == kRelatedEventSet) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::RelatedEventSet*>(_impl_.diagnostic_oneof_.related_event_set_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.diagnostic_oneof_.related_event_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::RelatedEventSet& Diagnostic::_internal_related_event_set() const {
  return diagnostic_oneof_case() == kRelatedEventSet ? *reinterpret_cast<::catapult::tracing::tracing::proto::RelatedEventSet*>(_impl_.diagnostic_oneof_.related_event_set_) : reinterpret_cast<::catapult::tracing::tracing::proto::RelatedEventSet&>(::catapult::tracing::tracing::proto::_RelatedEventSet_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::RelatedEventSet& Diagnostic::related_event_set() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  return _internal_related_event_set();
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NULLABLE Diagnostic::unsafe_arena_release_related_event_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  if (diagnostic_oneof_case() == kRelatedEventSet) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::RelatedEventSet*>(_impl_.diagnostic_oneof_.related_event_set_);
    _impl_.diagnostic_oneof_.related_event_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_related_event_set(
    ::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_diagnostic_oneof();
  if (value) {
    set_has_related_event_set();
    _impl_.diagnostic_oneof_.related_event_set_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NONNULL Diagnostic::_internal_mutable_related_event_set() {
  if (diagnostic_oneof_case() != kRelatedEventSet) {
    clear_diagnostic_oneof();
    set_has_related_event_set();
    _impl_.diagnostic_oneof_.related_event_set_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::RelatedEventSet>(GetArena()));
  }
  return reinterpret_cast<::catapult::tracing::tracing::proto::RelatedEventSet*>(_impl_.diagnostic_oneof_.related_event_set_);
}
inline ::catapult::tracing::tracing::proto::RelatedEventSet* PROTOBUF_NONNULL Diagnostic::mutable_related_event_set()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::catapult::tracing::tracing::proto::RelatedEventSet* _msg = _internal_mutable_related_event_set();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.related_event_set)
  return _msg;
}

// .catapult.tracing.tracing.proto.RelatedNameMap related_name_map = 5;
inline bool Diagnostic::has_related_name_map() const {
  return diagnostic_oneof_case() == kRelatedNameMap;
}
inline bool Diagnostic::_internal_has_related_name_map() const {
  return diagnostic_oneof_case() == kRelatedNameMap;
}
inline void Diagnostic::set_has_related_name_map() {
  _impl_._oneof_case_[0] = kRelatedNameMap;
}
inline void Diagnostic::clear_related_name_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() == kRelatedNameMap) {
    if (GetArena() == nullptr) {
      delete _impl_.diagnostic_oneof_.related_name_map_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.diagnostic_oneof_.related_name_map_ != nullptr) {
        _impl_.diagnostic_oneof_.related_name_map_->Clear();
      }
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NULLABLE Diagnostic::release_related_name_map() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  if (diagnostic_oneof_case() == kRelatedNameMap) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::RelatedNameMap*>(_impl_.diagnostic_oneof_.related_name_map_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.diagnostic_oneof_.related_name_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::RelatedNameMap& Diagnostic::_internal_related_name_map() const {
  return diagnostic_oneof_case() == kRelatedNameMap ? *reinterpret_cast<::catapult::tracing::tracing::proto::RelatedNameMap*>(_impl_.diagnostic_oneof_.related_name_map_) : reinterpret_cast<::catapult::tracing::tracing::proto::RelatedNameMap&>(::catapult::tracing::tracing::proto::_RelatedNameMap_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::RelatedNameMap& Diagnostic::related_name_map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  return _internal_related_name_map();
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NULLABLE Diagnostic::unsafe_arena_release_related_name_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  if (diagnostic_oneof_case() == kRelatedNameMap) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::RelatedNameMap*>(_impl_.diagnostic_oneof_.related_name_map_);
    _impl_.diagnostic_oneof_.related_name_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_related_name_map(
    ::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_diagnostic_oneof();
  if (value) {
    set_has_related_name_map();
    _impl_.diagnostic_oneof_.related_name_map_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NONNULL Diagnostic::_internal_mutable_related_name_map() {
  if (diagnostic_oneof_case() != kRelatedNameMap) {
    clear_diagnostic_oneof();
    set_has_related_name_map();
    _impl_.diagnostic_oneof_.related_name_map_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::RelatedNameMap>(GetArena()));
  }
  return reinterpret_cast<::catapult::tracing::tracing::proto::RelatedNameMap*>(_impl_.diagnostic_oneof_.related_name_map_);
}
inline ::catapult::tracing::tracing::proto::RelatedNameMap* PROTOBUF_NONNULL Diagnostic::mutable_related_name_map()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::catapult::tracing::tracing::proto::RelatedNameMap* _msg = _internal_mutable_related_name_map();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.related_name_map)
  return _msg;
}

// .catapult.tracing.tracing.proto.Scalar scalar = 6;
inline bool Diagnostic::has_scalar() const {
  return diagnostic_oneof_case() == kScalar;
}
inline bool Diagnostic::_internal_has_scalar() const {
  return diagnostic_oneof_case() == kScalar;
}
inline void Diagnostic::set_has_scalar() {
  _impl_._oneof_case_[0] = kScalar;
}
inline void Diagnostic::clear_scalar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() == kScalar) {
    if (GetArena() == nullptr) {
      delete _impl_.diagnostic_oneof_.scalar_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.diagnostic_oneof_.scalar_ != nullptr) {
        _impl_.diagnostic_oneof_.scalar_->Clear();
      }
    }
    clear_has_diagnostic_oneof();
  }
}
inline ::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NULLABLE Diagnostic::release_scalar() {
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.scalar)
  if (diagnostic_oneof_case() == kScalar) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::Scalar*>(_impl_.diagnostic_oneof_.scalar_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.diagnostic_oneof_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::catapult::tracing::tracing::proto::Scalar& Diagnostic::_internal_scalar() const {
  return diagnostic_oneof_case() == kScalar ? *reinterpret_cast<::catapult::tracing::tracing::proto::Scalar*>(_impl_.diagnostic_oneof_.scalar_) : reinterpret_cast<::catapult::tracing::tracing::proto::Scalar&>(::catapult::tracing::tracing::proto::_Scalar_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::Scalar& Diagnostic::scalar() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.scalar)
  return _internal_scalar();
}
inline ::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NULLABLE Diagnostic::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:catapult.tracing.tracing.proto.Diagnostic.scalar)
  if (diagnostic_oneof_case() == kScalar) {
    clear_has_diagnostic_oneof();
    auto* temp = reinterpret_cast<::catapult::tracing::tracing::proto::Scalar*>(_impl_.diagnostic_oneof_.scalar_);
    _impl_.diagnostic_oneof_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Diagnostic::unsafe_arena_set_allocated_scalar(
    ::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_diagnostic_oneof();
  if (value) {
    set_has_scalar();
    _impl_.diagnostic_oneof_.scalar_ = reinterpret_cast<::google::protobuf::MessageLite*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Diagnostic.scalar)
}
inline ::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NONNULL Diagnostic::_internal_mutable_scalar() {
  if (diagnostic_oneof_case() != kScalar) {
    clear_diagnostic_oneof();
    set_has_scalar();
    _impl_.diagnostic_oneof_.scalar_ = reinterpret_cast<::google::protobuf::MessageLite*>(
        ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::Scalar>(GetArena()));
  }
  return reinterpret_cast<::catapult::tracing::tracing::proto::Scalar*>(_impl_.diagnostic_oneof_.scalar_);
}
inline ::catapult::tracing::tracing::proto::Scalar* PROTOBUF_NONNULL Diagnostic::mutable_scalar()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::catapult::tracing::tracing::proto::Scalar* _msg = _internal_mutable_scalar();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.scalar)
  return _msg;
}

// string shared_diagnostic_guid = 7;
inline bool Diagnostic::has_shared_diagnostic_guid() const {
  return diagnostic_oneof_case() == kSharedDiagnosticGuid;
}
inline void Diagnostic::set_has_shared_diagnostic_guid() {
  _impl_._oneof_case_[0] = kSharedDiagnosticGuid;
}
inline void Diagnostic::clear_shared_diagnostic_guid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() == kSharedDiagnosticGuid) {
    _impl_.diagnostic_oneof_.shared_diagnostic_guid_.Destroy();
    clear_has_diagnostic_oneof();
  }
}
inline const std::string& Diagnostic::shared_diagnostic_guid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  return _internal_shared_diagnostic_guid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Diagnostic::set_shared_diagnostic_guid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() != kSharedDiagnosticGuid) {
    clear_diagnostic_oneof();

    set_has_shared_diagnostic_guid();
    _impl_.diagnostic_oneof_.shared_diagnostic_guid_.InitDefault();
  }
  _impl_.diagnostic_oneof_.shared_diagnostic_guid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}
inline std::string* PROTOBUF_NONNULL Diagnostic::mutable_shared_diagnostic_guid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shared_diagnostic_guid();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  return _s;
}
inline const std::string& Diagnostic::_internal_shared_diagnostic_guid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (diagnostic_oneof_case() != kSharedDiagnosticGuid) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.diagnostic_oneof_.shared_diagnostic_guid_.Get();
}
inline void Diagnostic::_internal_set_shared_diagnostic_guid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() != kSharedDiagnosticGuid) {
    clear_diagnostic_oneof();

    set_has_shared_diagnostic_guid();
    _impl_.diagnostic_oneof_.shared_diagnostic_guid_.InitDefault();
  }
  _impl_.diagnostic_oneof_.shared_diagnostic_guid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL Diagnostic::_internal_mutable_shared_diagnostic_guid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (diagnostic_oneof_case() != kSharedDiagnosticGuid) {
    clear_diagnostic_oneof();

    set_has_shared_diagnostic_guid();
    _impl_.diagnostic_oneof_.shared_diagnostic_guid_.InitDefault();
  }
  return _impl_.diagnostic_oneof_.shared_diagnostic_guid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE Diagnostic::release_shared_diagnostic_guid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
  if (diagnostic_oneof_case() != kSharedDiagnosticGuid) {
    return nullptr;
  }
  clear_has_diagnostic_oneof();
  return _impl_.diagnostic_oneof_.shared_diagnostic_guid_.Release();
}
inline void Diagnostic::set_allocated_shared_diagnostic_guid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_diagnostic_oneof()) {
    clear_diagnostic_oneof();
  }
  if (value != nullptr) {
    set_has_shared_diagnostic_guid();
    _impl_.diagnostic_oneof_.shared_diagnostic_guid_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Diagnostic.shared_diagnostic_guid)
}

inline bool Diagnostic::has_diagnostic_oneof() const {
  return diagnostic_oneof_case() != DIAGNOSTIC_ONEOF_NOT_SET;
}
inline void Diagnostic::clear_has_diagnostic_oneof() {
  _impl_._oneof_case_[0] = DIAGNOSTIC_ONEOF_NOT_SET;
}
inline Diagnostic::DiagnosticOneofCase Diagnostic::diagnostic_oneof_case() const {
  return Diagnostic::DiagnosticOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DiagnosticMap

// map<string, .catapult.tracing.tracing.proto.Diagnostic> diagnostic_map = 1;
inline int DiagnosticMap::_internal_diagnostic_map_size() const {
  return _internal_diagnostic_map().size();
}
inline int DiagnosticMap::diagnostic_map_size() const {
  return _internal_diagnostic_map_size();
}
inline void DiagnosticMap::clear_diagnostic_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.diagnostic_map_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>& DiagnosticMap::_internal_diagnostic_map() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.diagnostic_map_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>& DiagnosticMap::diagnostic_map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:catapult.tracing.tracing.proto.DiagnosticMap.diagnostic_map)
  return _internal_diagnostic_map();
}
inline ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>* PROTOBUF_NONNULL DiagnosticMap::_internal_mutable_diagnostic_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.diagnostic_map_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>* PROTOBUF_NONNULL DiagnosticMap::mutable_diagnostic_map()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:catapult.tracing.tracing.proto.DiagnosticMap.diagnostic_map)
  return _internal_mutable_diagnostic_map();
}

// -------------------------------------------------------------------

// RunningStatistics

// int32 count = 1;
inline void RunningStatistics::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t RunningStatistics::count() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.count)
  return _internal_count();
}
inline void RunningStatistics::set_count(::int32_t value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.count)
}
inline ::int32_t RunningStatistics::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void RunningStatistics::_internal_set_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// double max = 2;
inline void RunningStatistics::clear_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double RunningStatistics::max() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.max)
  return _internal_max();
}
inline void RunningStatistics::set_max(double value) {
  _internal_set_max(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.max)
}
inline double RunningStatistics::_internal_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_;
}
inline void RunningStatistics::_internal_set_max(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = value;
}

// double meanlogs = 3;
inline void RunningStatistics::clear_meanlogs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meanlogs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double RunningStatistics::meanlogs() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.meanlogs)
  return _internal_meanlogs();
}
inline void RunningStatistics::set_meanlogs(double value) {
  _internal_set_meanlogs(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.meanlogs)
}
inline double RunningStatistics::_internal_meanlogs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.meanlogs_;
}
inline void RunningStatistics::_internal_set_meanlogs(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.meanlogs_ = value;
}

// double mean = 4;
inline void RunningStatistics::clear_mean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mean_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double RunningStatistics::mean() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.mean)
  return _internal_mean();
}
inline void RunningStatistics::set_mean(double value) {
  _internal_set_mean(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.mean)
}
inline double RunningStatistics::_internal_mean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mean_;
}
inline void RunningStatistics::_internal_set_mean(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mean_ = value;
}

// double min = 5;
inline void RunningStatistics::clear_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double RunningStatistics::min() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.min)
  return _internal_min();
}
inline void RunningStatistics::set_min(double value) {
  _internal_set_min(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.min)
}
inline double RunningStatistics::_internal_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_;
}
inline void RunningStatistics::_internal_set_min(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = value;
}

// double sum = 6;
inline void RunningStatistics::clear_sum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double RunningStatistics::sum() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.sum)
  return _internal_sum();
}
inline void RunningStatistics::set_sum(double value) {
  _internal_set_sum(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.sum)
}
inline double RunningStatistics::_internal_sum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sum_;
}
inline void RunningStatistics::_internal_set_sum(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sum_ = value;
}

// double variance = 7;
inline void RunningStatistics::clear_variance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double RunningStatistics::variance() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.RunningStatistics.variance)
  return _internal_variance();
}
inline void RunningStatistics::set_variance(double value) {
  _internal_set_variance(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.RunningStatistics.variance)
}
inline double RunningStatistics::_internal_variance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.variance_;
}
inline void RunningStatistics::_internal_set_variance(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variance_ = value;
}

// -------------------------------------------------------------------

// Bin

// int32 bin_count = 1;
inline void Bin::clear_bin_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bin_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Bin::bin_count() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Bin.bin_count)
  return _internal_bin_count();
}
inline void Bin::set_bin_count(::int32_t value) {
  _internal_set_bin_count(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Bin.bin_count)
}
inline ::int32_t Bin::_internal_bin_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bin_count_;
}
inline void Bin::_internal_set_bin_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bin_count_ = value;
}

// repeated .catapult.tracing.tracing.proto.DiagnosticMap diagnostic_maps = 2;
inline int Bin::_internal_diagnostic_maps_size() const {
  return _internal_diagnostic_maps().size();
}
inline int Bin::diagnostic_maps_size() const {
  return _internal_diagnostic_maps_size();
}
inline void Bin::clear_diagnostic_maps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.diagnostic_maps_.Clear();
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL Bin::mutable_diagnostic_maps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return _internal_mutable_diagnostic_maps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>* PROTOBUF_NONNULL Bin::mutable_diagnostic_maps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_diagnostic_maps();
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Bin::diagnostic_maps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return _internal_diagnostic_maps().Get(index);
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL Bin::add_diagnostic_maps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::catapult::tracing::tracing::proto::DiagnosticMap* _add = _internal_mutable_diagnostic_maps()->Add();
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>& Bin::diagnostic_maps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.Bin.diagnostic_maps)
  return _internal_diagnostic_maps();
}
inline const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>&
Bin::_internal_diagnostic_maps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.diagnostic_maps_;
}
inline ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>* PROTOBUF_NONNULL
Bin::_internal_mutable_diagnostic_maps() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.diagnostic_maps_;
}

// -------------------------------------------------------------------

// SummaryOptions

// bool avg = 1;
inline void SummaryOptions::clear_avg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SummaryOptions::avg() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.avg)
  return _internal_avg();
}
inline void SummaryOptions::set_avg(bool value) {
  _internal_set_avg(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.avg)
}
inline bool SummaryOptions::_internal_avg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avg_;
}
inline void SummaryOptions::_internal_set_avg(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_ = value;
}

// bool geometric_mean = 2;
inline void SummaryOptions::clear_geometric_mean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.geometric_mean_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SummaryOptions::geometric_mean() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.geometric_mean)
  return _internal_geometric_mean();
}
inline void SummaryOptions::set_geometric_mean(bool value) {
  _internal_set_geometric_mean(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.geometric_mean)
}
inline bool SummaryOptions::_internal_geometric_mean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.geometric_mean_;
}
inline void SummaryOptions::_internal_set_geometric_mean(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.geometric_mean_ = value;
}

// bool std = 3;
inline void SummaryOptions::clear_std() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.std_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SummaryOptions::std() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.std)
  return _internal_std();
}
inline void SummaryOptions::set_std(bool value) {
  _internal_set_std(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.std)
}
inline bool SummaryOptions::_internal_std() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.std_;
}
inline void SummaryOptions::_internal_set_std(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.std_ = value;
}

// bool count = 4;
inline void SummaryOptions::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool SummaryOptions::count() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.count)
  return _internal_count();
}
inline void SummaryOptions::set_count(bool value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.count)
}
inline bool SummaryOptions::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void SummaryOptions::_internal_set_count(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// bool sum = 5;
inline void SummaryOptions::clear_sum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sum_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SummaryOptions::sum() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.sum)
  return _internal_sum();
}
inline void SummaryOptions::set_sum(bool value) {
  _internal_set_sum(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.sum)
}
inline bool SummaryOptions::_internal_sum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sum_;
}
inline void SummaryOptions::_internal_set_sum(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sum_ = value;
}

// bool min = 6;
inline void SummaryOptions::clear_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool SummaryOptions::min() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.min)
  return _internal_min();
}
inline void SummaryOptions::set_min(bool value) {
  _internal_set_min(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.min)
}
inline bool SummaryOptions::_internal_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_;
}
inline void SummaryOptions::_internal_set_min(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = value;
}

// bool max = 7;
inline void SummaryOptions::clear_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool SummaryOptions::max() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.max)
  return _internal_max();
}
inline void SummaryOptions::set_max(bool value) {
  _internal_set_max(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.max)
}
inline bool SummaryOptions::_internal_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_;
}
inline void SummaryOptions::_internal_set_max(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = value;
}

// bool nans = 8;
inline void SummaryOptions::clear_nans() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nans_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool SummaryOptions::nans() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.nans)
  return _internal_nans();
}
inline void SummaryOptions::set_nans(bool value) {
  _internal_set_nans(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.nans)
}
inline bool SummaryOptions::_internal_nans() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nans_;
}
inline void SummaryOptions::_internal_set_nans(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nans_ = value;
}

// repeated float percentile = 9;
inline int SummaryOptions::_internal_percentile_size() const {
  return _internal_percentile().size();
}
inline int SummaryOptions::percentile_size() const {
  return _internal_percentile_size();
}
inline void SummaryOptions::clear_percentile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.percentile_.Clear();
}
inline float SummaryOptions::percentile(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.SummaryOptions.percentile)
  return _internal_percentile().Get(index);
}
inline void SummaryOptions::set_percentile(int index, float value) {
  _internal_mutable_percentile()->Set(index, value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.SummaryOptions.percentile)
}
inline void SummaryOptions::add_percentile(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_percentile()->Add(value);
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.SummaryOptions.percentile)
}
inline const ::google::protobuf::RepeatedField<float>& SummaryOptions::percentile() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.SummaryOptions.percentile)
  return _internal_percentile();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL SummaryOptions::mutable_percentile()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.SummaryOptions.percentile)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_percentile();
}
inline const ::google::protobuf::RepeatedField<float>&
SummaryOptions::_internal_percentile() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.percentile_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
SummaryOptions::_internal_mutable_percentile() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.percentile_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Histogram

// string name = 1;
inline void Histogram::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Histogram::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Histogram::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.name)
}
inline std::string* PROTOBUF_NONNULL Histogram::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.name)
  return _s;
}
inline const std::string& Histogram::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Histogram::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL Histogram::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE Histogram::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void Histogram::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.name)
}

// .catapult.tracing.tracing.proto.UnitAndDirection unit = 2;
inline bool Histogram::has_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_ != nullptr);
  return value;
}
inline void Histogram::clear_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.unit_ != nullptr) _impl_.unit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::catapult::tracing::tracing::proto::UnitAndDirection& Histogram::_internal_unit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::catapult::tracing::tracing::proto::UnitAndDirection* p = _impl_.unit_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::UnitAndDirection&>(::catapult::tracing::tracing::proto::_UnitAndDirection_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::UnitAndDirection& Histogram::unit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.unit)
  return _internal_unit();
}
inline void Histogram::unsafe_arena_set_allocated_unit(
    ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unit_);
  }
  _impl_.unit_ = reinterpret_cast<::catapult::tracing::tracing::proto::UnitAndDirection*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.unit)
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NULLABLE Histogram::release_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::catapult::tracing::tracing::proto::UnitAndDirection* released = _impl_.unit_;
  _impl_.unit_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NULLABLE Histogram::unsafe_arena_release_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.unit)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::catapult::tracing::tracing::proto::UnitAndDirection* temp = _impl_.unit_;
  _impl_.unit_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NONNULL Histogram::_internal_mutable_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.unit_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::UnitAndDirection>(GetArena());
    _impl_.unit_ = reinterpret_cast<::catapult::tracing::tracing::proto::UnitAndDirection*>(p);
  }
  return _impl_.unit_;
}
inline ::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NONNULL Histogram::mutable_unit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::catapult::tracing::tracing::proto::UnitAndDirection* _msg = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.unit)
  return _msg;
}
inline void Histogram::set_allocated_unit(::catapult::tracing::tracing::proto::UnitAndDirection* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unit_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.unit_ = reinterpret_cast<::catapult::tracing::tracing::proto::UnitAndDirection*>(value);
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.unit)
}

// .catapult.tracing.tracing.proto.BinBoundaries bin_boundaries = 3;
inline bool Histogram::has_bin_boundaries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bin_boundaries_ != nullptr);
  return value;
}
inline void Histogram::clear_bin_boundaries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bin_boundaries_ != nullptr) _impl_.bin_boundaries_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::catapult::tracing::tracing::proto::BinBoundaries& Histogram::_internal_bin_boundaries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::catapult::tracing::tracing::proto::BinBoundaries* p = _impl_.bin_boundaries_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::BinBoundaries&>(::catapult::tracing::tracing::proto::_BinBoundaries_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::BinBoundaries& Histogram::bin_boundaries() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
  return _internal_bin_boundaries();
}
inline void Histogram::unsafe_arena_set_allocated_bin_boundaries(
    ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bin_boundaries_);
  }
  _impl_.bin_boundaries_ = reinterpret_cast<::catapult::tracing::tracing::proto::BinBoundaries*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NULLABLE Histogram::release_bin_boundaries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::catapult::tracing::tracing::proto::BinBoundaries* released = _impl_.bin_boundaries_;
  _impl_.bin_boundaries_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NULLABLE Histogram::unsafe_arena_release_bin_boundaries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.bin_boundaries)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::catapult::tracing::tracing::proto::BinBoundaries* temp = _impl_.bin_boundaries_;
  _impl_.bin_boundaries_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NONNULL Histogram::_internal_mutable_bin_boundaries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bin_boundaries_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::BinBoundaries>(GetArena());
    _impl_.bin_boundaries_ = reinterpret_cast<::catapult::tracing::tracing::proto::BinBoundaries*>(p);
  }
  return _impl_.bin_boundaries_;
}
inline ::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NONNULL Histogram::mutable_bin_boundaries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::catapult::tracing::tracing::proto::BinBoundaries* _msg = _internal_mutable_bin_boundaries();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
  return _msg;
}
inline void Histogram::set_allocated_bin_boundaries(::catapult::tracing::tracing::proto::BinBoundaries* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bin_boundaries_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.bin_boundaries_ = reinterpret_cast<::catapult::tracing::tracing::proto::BinBoundaries*>(value);
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.bin_boundaries)
}

// string description = 4;
inline void Histogram::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Histogram::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Histogram::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.description)
}
inline std::string* PROTOBUF_NONNULL Histogram::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.description)
  return _s;
}
inline const std::string& Histogram::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Histogram::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL Histogram::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE Histogram::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.description)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void Histogram::set_allocated_description(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.description)
}

// .catapult.tracing.tracing.proto.DiagnosticMap diagnostics = 5;
inline bool Histogram::has_diagnostics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.diagnostics_ != nullptr);
  return value;
}
inline void Histogram::clear_diagnostics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.diagnostics_ != nullptr) _impl_.diagnostics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Histogram::_internal_diagnostics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::catapult::tracing::tracing::proto::DiagnosticMap* p = _impl_.diagnostics_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::DiagnosticMap&>(::catapult::tracing::tracing::proto::_DiagnosticMap_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Histogram::diagnostics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.diagnostics)
  return _internal_diagnostics();
}
inline void Histogram::unsafe_arena_set_allocated_diagnostics(
    ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.diagnostics_);
  }
  _impl_.diagnostics_ = reinterpret_cast<::catapult::tracing::tracing::proto::DiagnosticMap*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.diagnostics)
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NULLABLE Histogram::release_diagnostics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::catapult::tracing::tracing::proto::DiagnosticMap* released = _impl_.diagnostics_;
  _impl_.diagnostics_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NULLABLE Histogram::unsafe_arena_release_diagnostics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.diagnostics)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::catapult::tracing::tracing::proto::DiagnosticMap* temp = _impl_.diagnostics_;
  _impl_.diagnostics_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL Histogram::_internal_mutable_diagnostics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.diagnostics_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::DiagnosticMap>(GetArena());
    _impl_.diagnostics_ = reinterpret_cast<::catapult::tracing::tracing::proto::DiagnosticMap*>(p);
  }
  return _impl_.diagnostics_;
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL Histogram::mutable_diagnostics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::catapult::tracing::tracing::proto::DiagnosticMap* _msg = _internal_mutable_diagnostics();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.diagnostics)
  return _msg;
}
inline void Histogram::set_allocated_diagnostics(::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.diagnostics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.diagnostics_ = reinterpret_cast<::catapult::tracing::tracing::proto::DiagnosticMap*>(value);
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.diagnostics)
}

// repeated double sample_values = 6;
inline int Histogram::_internal_sample_values_size() const {
  return _internal_sample_values().size();
}
inline int Histogram::sample_values_size() const {
  return _internal_sample_values_size();
}
inline void Histogram::clear_sample_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_values_.Clear();
}
inline double Histogram::sample_values(int index) const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.sample_values)
  return _internal_sample_values().Get(index);
}
inline void Histogram::set_sample_values(int index, double value) {
  _internal_mutable_sample_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.sample_values)
}
inline void Histogram::add_sample_values(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_sample_values()->Add(value);
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.Histogram.sample_values)
}
inline const ::google::protobuf::RepeatedField<double>& Histogram::sample_values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.Histogram.sample_values)
  return _internal_sample_values();
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL Histogram::mutable_sample_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.Histogram.sample_values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sample_values();
}
inline const ::google::protobuf::RepeatedField<double>&
Histogram::_internal_sample_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_values_;
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL
Histogram::_internal_mutable_sample_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sample_values_;
}

// int32 max_num_sample_values = 7;
inline void Histogram::clear_max_num_sample_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_num_sample_values_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t Histogram::max_num_sample_values() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.max_num_sample_values)
  return _internal_max_num_sample_values();
}
inline void Histogram::set_max_num_sample_values(::int32_t value) {
  _internal_set_max_num_sample_values(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.max_num_sample_values)
}
inline ::int32_t Histogram::_internal_max_num_sample_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_num_sample_values_;
}
inline void Histogram::_internal_set_max_num_sample_values(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_num_sample_values_ = value;
}

// int32 num_nans = 8;
inline void Histogram::clear_num_nans() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_nans_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t Histogram::num_nans() const {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.num_nans)
  return _internal_num_nans();
}
inline void Histogram::set_num_nans(::int32_t value) {
  _internal_set_num_nans(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:catapult.tracing.tracing.proto.Histogram.num_nans)
}
inline ::int32_t Histogram::_internal_num_nans() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_nans_;
}
inline void Histogram::_internal_set_num_nans(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_nans_ = value;
}

// repeated .catapult.tracing.tracing.proto.DiagnosticMap nan_diagnostics = 9;
inline int Histogram::_internal_nan_diagnostics_size() const {
  return _internal_nan_diagnostics().size();
}
inline int Histogram::nan_diagnostics_size() const {
  return _internal_nan_diagnostics_size();
}
inline void Histogram::clear_nan_diagnostics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nan_diagnostics_.Clear();
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL Histogram::mutable_nan_diagnostics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return _internal_mutable_nan_diagnostics()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>* PROTOBUF_NONNULL Histogram::mutable_nan_diagnostics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_nan_diagnostics();
}
inline const ::catapult::tracing::tracing::proto::DiagnosticMap& Histogram::nan_diagnostics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return _internal_nan_diagnostics().Get(index);
}
inline ::catapult::tracing::tracing::proto::DiagnosticMap* PROTOBUF_NONNULL Histogram::add_nan_diagnostics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::catapult::tracing::tracing::proto::DiagnosticMap* _add = _internal_mutable_nan_diagnostics()->Add();
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>& Histogram::nan_diagnostics() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.Histogram.nan_diagnostics)
  return _internal_nan_diagnostics();
}
inline const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>&
Histogram::_internal_nan_diagnostics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nan_diagnostics_;
}
inline ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::DiagnosticMap>* PROTOBUF_NONNULL
Histogram::_internal_mutable_nan_diagnostics() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.nan_diagnostics_;
}

// .catapult.tracing.tracing.proto.RunningStatistics running = 10;
inline bool Histogram::has_running() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.running_ != nullptr);
  return value;
}
inline void Histogram::clear_running() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.running_ != nullptr) _impl_.running_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::catapult::tracing::tracing::proto::RunningStatistics& Histogram::_internal_running() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::catapult::tracing::tracing::proto::RunningStatistics* p = _impl_.running_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::RunningStatistics&>(::catapult::tracing::tracing::proto::_RunningStatistics_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::RunningStatistics& Histogram::running() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.running)
  return _internal_running();
}
inline void Histogram::unsafe_arena_set_allocated_running(
    ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.running_);
  }
  _impl_.running_ = reinterpret_cast<::catapult::tracing::tracing::proto::RunningStatistics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.running)
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NULLABLE Histogram::release_running() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::catapult::tracing::tracing::proto::RunningStatistics* released = _impl_.running_;
  _impl_.running_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NULLABLE Histogram::unsafe_arena_release_running() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.running)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::catapult::tracing::tracing::proto::RunningStatistics* temp = _impl_.running_;
  _impl_.running_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NONNULL Histogram::_internal_mutable_running() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.running_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::RunningStatistics>(GetArena());
    _impl_.running_ = reinterpret_cast<::catapult::tracing::tracing::proto::RunningStatistics*>(p);
  }
  return _impl_.running_;
}
inline ::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NONNULL Histogram::mutable_running()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::catapult::tracing::tracing::proto::RunningStatistics* _msg = _internal_mutable_running();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.running)
  return _msg;
}
inline void Histogram::set_allocated_running(::catapult::tracing::tracing::proto::RunningStatistics* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.running_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.running_ = reinterpret_cast<::catapult::tracing::tracing::proto::RunningStatistics*>(value);
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.running)
}

// map<int32, .catapult.tracing.tracing.proto.Bin> all_bins = 11;
inline int Histogram::_internal_all_bins_size() const {
  return _internal_all_bins().size();
}
inline int Histogram::all_bins_size() const {
  return _internal_all_bins_size();
}
inline void Histogram::clear_all_bins() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_bins_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::catapult::tracing::tracing::proto::Bin>& Histogram::_internal_all_bins() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.all_bins_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::catapult::tracing::tracing::proto::Bin>& Histogram::all_bins() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:catapult.tracing.tracing.proto.Histogram.all_bins)
  return _internal_all_bins();
}
inline ::google::protobuf::Map<::int32_t, ::catapult::tracing::tracing::proto::Bin>* PROTOBUF_NONNULL Histogram::_internal_mutable_all_bins() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.all_bins_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::catapult::tracing::tracing::proto::Bin>* PROTOBUF_NONNULL Histogram::mutable_all_bins()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:catapult.tracing.tracing.proto.Histogram.all_bins)
  return _internal_mutable_all_bins();
}

// .catapult.tracing.tracing.proto.SummaryOptions summary_options = 12;
inline bool Histogram::has_summary_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.summary_options_ != nullptr);
  return value;
}
inline void Histogram::clear_summary_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.summary_options_ != nullptr) _impl_.summary_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::catapult::tracing::tracing::proto::SummaryOptions& Histogram::_internal_summary_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::catapult::tracing::tracing::proto::SummaryOptions* p = _impl_.summary_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::catapult::tracing::tracing::proto::SummaryOptions&>(::catapult::tracing::tracing::proto::_SummaryOptions_default_instance_);
}
inline const ::catapult::tracing::tracing::proto::SummaryOptions& Histogram::summary_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.Histogram.summary_options)
  return _internal_summary_options();
}
inline void Histogram::unsafe_arena_set_allocated_summary_options(
    ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.summary_options_);
  }
  _impl_.summary_options_ = reinterpret_cast<::catapult::tracing::tracing::proto::SummaryOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:catapult.tracing.tracing.proto.Histogram.summary_options)
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NULLABLE Histogram::release_summary_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::catapult::tracing::tracing::proto::SummaryOptions* released = _impl_.summary_options_;
  _impl_.summary_options_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NULLABLE Histogram::unsafe_arena_release_summary_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:catapult.tracing.tracing.proto.Histogram.summary_options)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::catapult::tracing::tracing::proto::SummaryOptions* temp = _impl_.summary_options_;
  _impl_.summary_options_ = nullptr;
  return temp;
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NONNULL Histogram::_internal_mutable_summary_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.summary_options_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::catapult::tracing::tracing::proto::SummaryOptions>(GetArena());
    _impl_.summary_options_ = reinterpret_cast<::catapult::tracing::tracing::proto::SummaryOptions*>(p);
  }
  return _impl_.summary_options_;
}
inline ::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NONNULL Histogram::mutable_summary_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::catapult::tracing::tracing::proto::SummaryOptions* _msg = _internal_mutable_summary_options();
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.Histogram.summary_options)
  return _msg;
}
inline void Histogram::set_allocated_summary_options(::catapult::tracing::tracing::proto::SummaryOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.summary_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.summary_options_ = reinterpret_cast<::catapult::tracing::tracing::proto::SummaryOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:catapult.tracing.tracing.proto.Histogram.summary_options)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HistogramSet

// repeated .catapult.tracing.tracing.proto.Histogram histograms = 1;
inline int HistogramSet::_internal_histograms_size() const {
  return _internal_histograms().size();
}
inline int HistogramSet::histograms_size() const {
  return _internal_histograms_size();
}
inline void HistogramSet::clear_histograms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.histograms_.Clear();
}
inline ::catapult::tracing::tracing::proto::Histogram* PROTOBUF_NONNULL HistogramSet::mutable_histograms(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return _internal_mutable_histograms()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::Histogram>* PROTOBUF_NONNULL HistogramSet::mutable_histograms()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:catapult.tracing.tracing.proto.HistogramSet.histograms)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_histograms();
}
inline const ::catapult::tracing::tracing::proto::Histogram& HistogramSet::histograms(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return _internal_histograms().Get(index);
}
inline ::catapult::tracing::tracing::proto::Histogram* PROTOBUF_NONNULL HistogramSet::add_histograms()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::catapult::tracing::tracing::proto::Histogram* _add = _internal_mutable_histograms()->Add();
  // @@protoc_insertion_point(field_add:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::Histogram>& HistogramSet::histograms() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:catapult.tracing.tracing.proto.HistogramSet.histograms)
  return _internal_histograms();
}
inline const ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::Histogram>&
HistogramSet::_internal_histograms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.histograms_;
}
inline ::google::protobuf::RepeatedPtrField<::catapult::tracing::tracing::proto::Histogram>* PROTOBUF_NONNULL
HistogramSet::_internal_mutable_histograms() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.histograms_;
}

// map<string, .catapult.tracing.tracing.proto.Diagnostic> shared_diagnostics = 2;
inline int HistogramSet::_internal_shared_diagnostics_size() const {
  return _internal_shared_diagnostics().size();
}
inline int HistogramSet::shared_diagnostics_size() const {
  return _internal_shared_diagnostics_size();
}
inline void HistogramSet::clear_shared_diagnostics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shared_diagnostics_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>& HistogramSet::_internal_shared_diagnostics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shared_diagnostics_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>& HistogramSet::shared_diagnostics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:catapult.tracing.tracing.proto.HistogramSet.shared_diagnostics)
  return _internal_shared_diagnostics();
}
inline ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>* PROTOBUF_NONNULL HistogramSet::_internal_mutable_shared_diagnostics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.shared_diagnostics_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::catapult::tracing::tracing::proto::Diagnostic>* PROTOBUF_NONNULL HistogramSet::mutable_shared_diagnostics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:catapult.tracing.tracing.proto.HistogramSet.shared_diagnostics)
  return _internal_mutable_shared_diagnostics();
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace tracing
}  // namespace tracing
}  // namespace catapult


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::catapult::tracing::tracing::proto::BinBoundaryDetailedSpec_Type> : std::true_type {};
template <>
struct is_proto_enum<::catapult::tracing::tracing::proto::ImprovementDirection> : std::true_type {};
template <>
struct is_proto_enum<::catapult::tracing::tracing::proto::Unit> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // histogram_2eproto_2epb_2eh
